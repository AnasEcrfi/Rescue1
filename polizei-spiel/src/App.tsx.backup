import React, { useState, useEffect } from 'react';
import { MapContainer, TileLayer, Marker, Popup, Polyline, useMap } from 'react-leaflet';
import L from 'leaflet';
import 'leaflet/dist/leaflet.css';
import './App.css';
import { getRoute, convertToLeafletFormat, getPointAlongRoute, getStraightLineRoute, calculateDistance } from './services/routingService';
import StatisticsModal, { type Statistics } from './components/StatisticsModal';
import Toast, { type ToastData } from './components/Toast';
import ProtocolLog, { type LogEntry } from './components/ProtocolLog';
import { soundManager } from './utils/soundEffects';
import type { VehicleStatus, VehicleType, VehicleTypeConfig, PoliceStation, Vehicle, Call, Incident, Achievement } from './types';
import { vehicleTypeConfigs } from './constants/vehicleTypes';
import { policeStations, frankfurtLocations } from './constants/locations';
import { incidentTypes, incidentProcessingTimes, escalationRules } from './constants/incidents';
import { getTimeOfDay, getMapOverlayOpacity, getWeightedIncidentType, calculateMinETA, createIncidentIcon, createVehicleIcon, createCallIcon } from './utils/gameLogic';
import { getRandomCallText, generateCallbackNumber } from './constants/callTexts';
import CallModal from './components/CallModal';

// Fix Leaflet default marker icon issue
delete (L.Icon.Default.prototype as any)._getIconUrl;
L.Icon.Default.mergeOptions({
  iconRetinaUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-icon-2x.png',
  iconUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-icon.png',
  shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-shadow.png',
});

// Vehicle Status Types (lstsim.de style - ERWEITERT)
type VehicleStatus = 'S1' | 'S3' | 'S4' | 'S5' | 'S6' | 'S8';
// S1: Bereit an Wache (gr√ºn)
// S3: Anfahrt zum Einsatz (orange)
// S4: Am Einsatzort, Bearbeitung (rot)
// S5: Sprechwunsch (blau) - Fahrzeug m√∂chte mit Leitstelle sprechen
// S6: Au√üer Dienst (grau) - Fahrzeug defekt/Schichtende
// S8: R√ºckfahrt zur Wache (blau) - KANN umgeleitet werden!

// Fahrzeugtypen (lstsim.de inspiriert, Polizei-Adaption)
type VehicleType = 'Streifenwagen' | 'SEK' | 'Zivilfahrzeug' | 'Polizeihubschrauber';

interface VehicleTypeConfig {
  type: VehicleType;
  color: string;
  maxSpeed: number; // km/h
  acceleration: number; // m/s¬≤
  suitableFor: string[]; // Welche Einsatztypen
  displayName: string;
  icon: string;
}

// Types
interface PoliceStation {
  id: number;
  name: string;
  position: [number, number];
}

interface Vehicle {
  id: number;
  stationId: number;
  position: [number, number];
  assignedIncidentId: number | null;
  routeIndex: number;
  route: [number, number][] | null;
  routeProgress: number;
  bearing: number;
  routeDuration: number;
  routeStartTime: number;
  totalDistanceTraveled: number;
  isAvailable: boolean;
  status: VehicleStatus;
  processingStartTime: number | null;
  processingDuration: number;
  // NEU: Fahrzeugtyp und erweiterte Eigenschaften
  vehicleType: VehicleType;
  speakRequest: string | null; // S5: Was m√∂chte das Fahrzeug mitteilen?
  outOfServiceReason: string | null; // S6: Warum au√üer Dienst?
  outOfServiceUntil: number | null; // S6: Wann wieder verf√ºgbar?
  canBeRedirected: boolean; // Kann w√§hrend S8 umgeleitet werden?
}

// Call (Notruf) - kommt rein bevor ein Einsatz erstellt wird
interface Call {
  id: number;
  type: string;
  position: [number, number];
  priority: 'low' | 'medium' | 'high';
  description: string;
  locationName: string;
  timestamp: number;
  answered: boolean;
}

interface Incident {
  id: number;
  type: string;
  position: [number, number];
  assignedVehicleIds: number[]; // Array for multiple vehicles
  priority: 'low' | 'medium' | 'high';
  description: string;
  timeRemaining: number;
  locationName: string;
  spawnTime: number;
  requiredVehicles: number; // How many vehicles needed
  arrivedVehicles: number; // How many vehicles have arrived
  processingDuration: number; // How long to process at scene
  canEscalate: boolean; // Kann dieser Einsatz eskalieren?
  escalationTime: number | null; // Wann soll eskaliert werden (timestamp)
  hasEscalated: boolean; // Ist bereits eskaliert?
}

interface Achievement {
  id: string;
  title: string;
  description: string;
  unlocked: boolean;
  icon: string;
}

// Fahrzeugtyp-Konfigurationen (lstsim.de inspiriert)
const vehicleTypeConfigs: { [key in VehicleType]: VehicleTypeConfig } = {
  'Streifenwagen': {
    type: 'Streifenwagen',
    color: '#0A84FF',
    maxSpeed: 160,
    acceleration: 3.5,
    suitableFor: ['Diebstahl', 'Ruhest√∂rung', 'Verd√§chtige Person', 'Verkehrsunfall', 'Raub', 'Vandalismus', 'H√§usliche Gewalt'],
    displayName: 'FuStW',
    icon: 'FZ',
  },
  'SEK': {
    type: 'SEK',
    color: '#FF453A',
    maxSpeed: 180,
    acceleration: 4.0,
    suitableFor: ['Bank√ºberfall', 'Geiselnahme', 'Schl√§gerei', 'Einbruch'],
    displayName: 'SEK',
    icon: 'SK',
  },
  'Zivilfahrzeug': {
    type: 'Zivilfahrzeug',
    color: '#8E8E93',
    maxSpeed: 140,
    acceleration: 3.0,
    suitableFor: ['Verd√§chtige Person', 'Diebstahl', 'Vandalismus'],
    displayName: 'Zivil',
    icon: 'ZV',
  },
  'Polizeihubschrauber': {
    type: 'Polizeihubschrauber',
    color: '#30D158',
    maxSpeed: 250,
    acceleration: 5.0,
    suitableFor: ['Verfolgungsjagd', 'Gro√üeinsatz', 'Demonstration', 'Bank√ºberfall', 'Geiselnahme'],
    displayName: 'Heli',
    icon: 'HB',
  },
};

// Police stations in Frankfurt am Main
const policeStations: PoliceStation[] = [
  { id: 1, name: 'Polizeirevier Innenstadt', position: [50.1109, 8.6821] },
  { id: 2, name: 'Polizeirevier Bahnhofsviertel', position: [50.1070, 8.6647] },
  { id: 3, name: 'Polizeirevier Sachsenhausen', position: [50.1025, 8.6738] },
  { id: 4, name: 'Polizeirevier Bornheim', position: [50.1261, 8.7166] },
  { id: 5, name: 'Polizeirevier Westend', position: [50.1188, 8.6501] },
];

// Real Frankfurt locations for incidents
const frankfurtLocations = [
  { name: 'R√∂merberg', position: [50.1104, 8.6827] },
  { name: 'Hauptbahnhof', position: [50.1070, 8.6638] },
  { name: 'Alte Oper', position: [50.1158, 8.6726] },
  { name: 'Zeil (Shopping Street)', position: [50.1148, 8.6848] },
  { name: 'Sachsenhausen Ufer', position: [50.1025, 8.6780] },
  { name: 'Palmengarten', position: [50.1223, 8.6613] },
  { name: 'Goethe Universit√§t', position: [50.1280, 8.6644] },
  { name: 'Hauptwache', position: [50.1136, 8.6791] },
  { name: 'Konstablerwache', position: [50.1156, 8.6924] },
  { name: 'Frankfurt Zoo', position: [50.1159, 8.7023] },
];

// Processing durations for each incident type (in seconds)
const incidentProcessingTimes: { [key: string]: number } = {
  'Diebstahl': 180,           // 3 Min
  'Einbruch': 300,            // 5 Min
  'Verkehrsunfall': 240,      // 4 Min
  'Ruhest√∂rung': 120,         // 2 Min
  'Schl√§gerei': 210,          // 3.5 Min
  'Verd√§chtige Person': 150,  // 2.5 Min
  'Bank√ºberfall': 420,        // 7 Min
  'Demonstration': 360,       // 6 Min
  'Geiselnahme': 480,         // 8 Min
  'H√§usliche Gewalt': 270,    // 4.5 Min
  'Raub': 240,                // 4 Min
  'Vandalismus': 150,         // 2.5 Min
};

const incidentTypes = [
  { type: 'Diebstahl', description: 'Diebstahl gemeldet', priority: 'medium', requiredVehicles: 1 },
  { type: 'Einbruch', description: 'Einbruch in Wohnung', priority: 'high', requiredVehicles: 2 },
  { type: 'Verkehrsunfall', description: 'Verkehrsunfall mit Verletzten', priority: 'high', requiredVehicles: 2 },
  { type: 'Ruhest√∂rung', description: 'Ruhest√∂rung', priority: 'low', requiredVehicles: 1 },
  { type: 'Schl√§gerei', description: 'Schl√§gerei gemeldet', priority: 'high', requiredVehicles: 2 },
  { type: 'Verd√§chtige Person', description: 'Verd√§chtige Person gesichtet', priority: 'medium', requiredVehicles: 1 },
  { type: 'Bank√ºberfall', description: 'Bank√ºberfall im Gange', priority: 'high', requiredVehicles: 3 },
  { type: 'Demonstration', description: 'Unangemeldete Demonstration', priority: 'medium', requiredVehicles: 3 },
  { type: 'Geiselnahme', description: 'Geiselnahme gemeldet', priority: 'high', requiredVehicles: 3 },
  { type: 'H√§usliche Gewalt', description: 'H√§usliche Gewalt', priority: 'high', requiredVehicles: 2 },
  { type: 'Raub', description: 'Raub auf offener Stra√üe', priority: 'high', requiredVehicles: 2 },
  { type: 'Vandalismus', description: 'Sachbesch√§digung', priority: 'low', requiredVehicles: 1 },
];

// Eskalations-Regeln: Von welchem Einsatztyp zu welchem kann eskaliert werden
const escalationRules: { [key: string]: { newType: string; newPriority: 'low' | 'medium' | 'high' } } = {
  'Diebstahl': { newType: 'Raub', newPriority: 'high' },
  'Verd√§chtige Person': { newType: 'Schl√§gerei', newPriority: 'high' },
  'Ruhest√∂rung': { newType: 'Schl√§gerei', newPriority: 'high' },
  'Schl√§gerei': { newType: 'Bank√ºberfall', newPriority: 'high' },
};

// Helper: Bestimme Tageszeit-Typ basierend auf Stunde
const getTimeOfDay = (hour: number): 'night' | 'dusk' | 'day' | 'rushHour' => {
  if (hour >= 22 || hour < 6) return 'night';
  if ((hour >= 6 && hour < 8) || (hour >= 18 && hour < 20)) return 'dusk';
  if ((hour >= 7 && hour < 9) || (hour >= 17 && hour < 19)) return 'rushHour';
  return 'day';
};

// Helper: Berechne Overlay-Opacity basierend auf Tageszeit
const getMapOverlayOpacity = (hour: number): number => {
  if (hour >= 18 && hour < 20) return 0.2; // D√§mmerung abends
  if (hour >= 6 && hour < 8) return 0.2;   // D√§mmerung morgens
  if (hour >= 20 || hour < 6) return 0.5;  // Nacht
  return 0; // Tag
};

// Helper: Gewichtete Zufallsauswahl basierend auf Tageszeit
const getWeightedIncidentType = (hour: number) => {
  const timeOfDay = getTimeOfDay(hour);

  // Basis-Gewichtungen (alle Einsatztypen mit Standardgewichtung 1)
  const weights = incidentTypes.map(incident => {
    let weight = 1;

    // Nachts (22:00-05:59)
    if (timeOfDay === 'night') {
      if (['Einbruch', 'Vandalismus'].includes(incident.type)) weight *= 3;
      if (['H√§usliche Gewalt', 'Raub'].includes(incident.type)) weight *= 2;
      if (['Verkehrsunfall', 'Demonstration'].includes(incident.type)) weight *= 0.5;
    }

    // Tags√ºber (08:00-17:59)
    if (timeOfDay === 'day') {
      if (['Verkehrsunfall', 'Diebstahl'].includes(incident.type)) weight *= 2;
      if (incident.type === 'Demonstration') weight *= 3;
      if (['Einbruch', 'Vandalismus'].includes(incident.type)) weight *= 0.5;
    }

    // Rush Hour (07:00-09:00, 17:00-19:00)
    if (timeOfDay === 'rushHour') {
      if (incident.type === 'Verkehrsunfall') weight *= 3;
      if (incident.type === 'Ruhest√∂rung') weight *= 2;
    }

    return weight;
  });

  // Gewichtete Zufallsauswahl
  const totalWeight = weights.reduce((sum, w) => sum + w, 0);
  let random = Math.random() * totalWeight;

  for (let i = 0; i < incidentTypes.length; i++) {
    random -= weights[i];
    if (random <= 0) {
      return incidentTypes[i];
    }
  }

  // Fallback (sollte nie erreicht werden)
  return incidentTypes[0];
};

// OPTIMIERUNG 5: Berechne minimale ETA von allen zugewiesenen Fahrzeugen
const calculateMinETA = (incident: Incident, vehicles: Vehicle[]): number => {
  const assignedVehicles = vehicles.filter(v =>
    incident.assignedVehicleIds.includes(v.id)
  );

  if (assignedVehicles.length === 0) return 0;

  const etas = assignedVehicles.map(v => {
    if (v.status === 'S3') {
      // Noch unterwegs
      const remaining = v.routeDuration - ((Date.now() - v.routeStartTime) / 1000);
      return Math.max(0, remaining / 60); // in Minuten
    }
    return 0;
  });

  return Math.min(...etas.filter(eta => eta > 0)) || 0;
};

// Modern incident marker (mit Eskalations-Effekt)
const createIncidentIcon = (priority: 'low' | 'medium' | 'high', hasEscalated: boolean = false) => {
  const colors = {
    high: '#FF453A',
    medium: '#FF9F0A',
    low: '#30D158'
  };
  const color = colors[priority];
  const pulseClass = hasEscalated ? 'incident-pulse-escalation' : 'incident-pulse';

  return L.divIcon({
    className: 'incident-marker',
    html: `
      <div class="incident-marker-container">
        <div class="${pulseClass}" style="background: ${color}"></div>
        <svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
          <circle cx="16" cy="16" r="14" fill="${color}" stroke="white" stroke-width="3"/>
          <path d="M16 10 L16 18 M16 22 L16 23" stroke="white" stroke-width="3" stroke-linecap="round"/>
        </svg>
      </div>
    `,
    iconSize: [32, 32],
    iconAnchor: [16, 16],
  });
};

// Modern police station marker - Hessischer Polizeistern
const createStationIcon = () => {
  return L.divIcon({
    className: 'station-marker',
    html: `
      <div class="station-marker-container">
        <div style="width: 48px; height: 48px; background: rgba(48, 209, 88, 0.15); border-radius: 50%; display: flex; align-items: center; justify-content: center;">
          <img src="/polizeistern-hessen.svg" alt="Polizeiwache" width="36" height="36" style="filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2));" />
        </div>
      </div>
    `,
    iconSize: [48, 48],
    iconAnchor: [24, 24],
  });
};

// Map center updater component
const MapCenterUpdater: React.FC<{ center: [number, number]; zoom?: number }> = ({ center, zoom = 16 }) => {
  const map = useMap();
  useEffect(() => {
    map.setView(center, zoom, { animate: true, duration: 0.5 });
  }, [center, zoom, map]);
  return null;
};

// VehicleMarker component with independent Blaulicht animation
interface VehicleMarkerProps {
  position: [number, number];
  bearing: number;
  status: VehicleStatus;
  vehicle: Vehicle;
}

const VehicleMarker: React.FC<VehicleMarkerProps> = ({ position, status, vehicle }) => {
  const [blaulichtOn, setBlaulichtOn] = useState(false);

  // ECE-R65 / DIN 14620 compliant Blaulicht pattern - only for this vehicle
  useEffect(() => {
    // Only animate if vehicle is on mission (S3 or S4)
    if (status !== 'S3' && status !== 'S4') {
      setBlaulichtOn(false);
      return;
    }

    let step = 0;
    const pattern = [
      { duration: 80, state: true },   // First flash
      { duration: 80, state: false },  // Short pause between flashes
      { duration: 80, state: true },   // Second flash (Doppelblitz)
      { duration: 260, state: false }, // Pause until next group (~500ms total)
    ];

    const runPattern = () => {
      setBlaulichtOn(pattern[step].state);
      setTimeout(() => {
        step = (step + 1) % pattern.length;
        runPattern();
      }, pattern[step].duration);
    };

    runPattern();
  }, [status]);

  // Determine which CSS class to use based on status and blaulicht state
  const isBlaulichtActive = (status === 'S3' || status === 'S4') && blaulichtOn;
  const vehicleClass = isBlaulichtActive ? 'vehicle-icon-blaulicht-on' : 'vehicle-icon-blaulicht-off';

  const icon = L.divIcon({
    className: 'vehicle-marker',
    html: `
      <div class="vehicle-marker-container">
        <div class="${vehicleClass}"></div>
      </div>
    `,
    iconSize: [64, 64],
    iconAnchor: [32, 32],
  });

  const statusLabels: { [key in VehicleStatus]: string } = {
    S1: 'Bereit',
    S3: 'Anfahrt',
    S4: 'Am Einsatzort',
    S5: 'Sprechwunsch',
    S6: 'Au√üer Dienst',
    S8: 'R√ºckfahrt'
  };

  return (
    <Marker position={position} icon={icon}>
      <Popup>
        <strong>Fahrzeug S-{vehicle.id.toString().padStart(2, '0')}</strong><br />
        Status: {statusLabels[status]}
      </Popup>
    </Marker>
  );
};

type Difficulty = 'Leicht' | 'Mittel' | 'Schwer';

// Achievement definitions
const achievementDefinitions = [
  {
    id: 'first_response',
    title: 'Erster Einsatz',
    description: 'Schlie√üe deinen ersten Einsatz erfolgreich ab',
    icon: 'üéñÔ∏è',
    condition: (stats: Statistics) => stats.totalResolved >= 1,
  },
  {
    id: 'century',
    title: 'Jahrhundert',
    description: 'Schlie√üe 100 Eins√§tze erfolgreich ab',
    icon: 'üèÜ',
    condition: (stats: Statistics) => stats.totalResolved >= 100,
  },
  {
    id: 'streak_10',
    title: 'Im Flow',
    description: 'Erreiche eine Serie von 10 erfolgreichen Eins√§tzen',
    icon: 'üî•',
    condition: (stats: Statistics) => stats.currentStreak >= 10,
  },
  {
    id: 'speed_demon',
    title: 'Blitzschnell',
    description: 'Durchschnittliche Reaktionszeit unter 60 Sekunden',
    icon: '‚ö°',
    condition: (stats: Statistics) => {
      if (stats.totalResponseTimes.length === 0) return false;
      const avg = stats.totalResponseTimes.reduce((a, b) => a + b, 0) / stats.totalResponseTimes.length;
      return avg < 60;
    },
  },
  {
    id: 'perfect_shift',
    title: 'Perfekte Schicht',
    description: 'Keine fehlgeschlagenen Eins√§tze in einer Schicht mit 20+ Eins√§tzen',
    icon: 'üíé',
    condition: (stats: Statistics) => stats.totalResolved >= 20 && stats.totalFailed === 0,
  },
];

// LocalStorage keys
const STORAGE_KEYS = {
  ACHIEVEMENTS: 'polizei_achievements',
  STATS: 'polizei_stats',
  HIGH_SCORE: 'polizei_high_score',
};

function App() {
  const [gameStarted, setGameStarted] = useState(false);
  const [selectedStation, setSelectedStation] = useState<number | null>(null);
  const [vehicles, setVehicles] = useState<Vehicle[]>([]);
  const [incidents, setIncidents] = useState<Incident[]>([]);
  const [calls, setCalls] = useState<Call[]>([]); // NEW: Calls system
  const [callIdCounter, setCallIdCounter] = useState(1); // NEW: Call ID counter
  const [selectedCall, setSelectedCall] = useState<Call | null>(null); // NEU: Ausgew√§hlter Anruf f√ºr Modal
  const [isCallModalOpen, setIsCallModalOpen] = useState(false); // NEU: Call Modal State
  const [score, setScore] = useState(0);
  const [incidentCounter, setIncidentCounter] = useState(1);
  const [mapCenter, setMapCenter] = useState<[number, number]>([50.1109, 8.6821]);

  // State for features
  const [selectedTime, setSelectedTime] = useState<number>(8);
  const [gameTime, setGameTime] = useState<number>(8 * 60);
  const [difficulty, setDifficulty] = useState<Difficulty>('Mittel');
  const [gameSpeed, setGameSpeed] = useState<1 | 2 | 3 | 4>(1); // Spielgeschwindigkeit
  const [isPaused, setIsPaused] = useState(false); // Pause-Status
  const [statistics, setStatistics] = useState<Statistics>({
    totalResolved: 0,
    totalFailed: 0,
    totalResponseTimes: [],
    incidentsByType: {},
    currentStreak: 0,
    bestStreak: 0,
    totalDistance: 0,
  });
  const [showStatsModal, setShowStatsModal] = useState(false);
  const [toasts, setToasts] = useState<ToastData[]>([]);
  const [toastCounter, setToastCounter] = useState(1);
  const [logs, setLogs] = useState<LogEntry[]>([]);
  const [logCounter, setLogCounter] = useState(1);
  const [achievements, setAchievements] = useState<Achievement[]>([]);
  const [showAchievementToast, setShowAchievementToast] = useState<Achievement | null>(null);
  const [vehicleFilter, setVehicleFilter] = useState<VehicleStatus | 'all'>('all');
  const [selectedVehicleId, setSelectedVehicleId] = useState<number | null>(null);
  const [currentTime, setCurrentTime] = useState(Date.now()); // For live call timer updates

  // Load saved data on mount (mit Error Handling f√ºr LocalStorage)
  useEffect(() => {
    try {
      const savedAchievements = localStorage.getItem(STORAGE_KEYS.ACHIEVEMENTS);
      if (savedAchievements) {
        setAchievements(JSON.parse(savedAchievements));
      } else {
        setAchievements(achievementDefinitions.map(a => ({ ...a, unlocked: false })));
      }

      const savedStats = localStorage.getItem(STORAGE_KEYS.STATS);
      if (savedStats) {
        setStatistics(JSON.parse(savedStats));
      }
    } catch (error) {
      console.error('Fehler beim Laden der gespeicherten Daten:', error);
      // Fallback: Neue Achievements initialisieren
      setAchievements(achievementDefinitions.map(a => ({ ...a, unlocked: false })));
    }
  }, []);

  // Save data whenever it changes (mit Error Handling f√ºr LocalStorage)
  useEffect(() => {
    if (gameStarted) {
      try {
        localStorage.setItem(STORAGE_KEYS.STATS, JSON.stringify(statistics));
        localStorage.setItem(STORAGE_KEYS.ACHIEVEMENTS, JSON.stringify(achievements));
        if (score > 0) {
          const highScore = localStorage.getItem(STORAGE_KEYS.HIGH_SCORE);
          if (!highScore || score > parseInt(highScore)) {
            localStorage.setItem(STORAGE_KEYS.HIGH_SCORE, score.toString());
          }
        }
      } catch (error) {
        console.error('Fehler beim Speichern der Daten:', error);
      }
    }
  }, [statistics, achievements, score, gameStarted]);

  // Check for new achievements
  useEffect(() => {
    achievements.forEach((achievement, index) => {
      if (!achievement.unlocked) {
        const def = achievementDefinitions.find(a => a.id === achievement.id);
        if (def && def.condition(statistics)) {
          const newAchievements = [...achievements];
          newAchievements[index] = { ...achievement, unlocked: true };
          setAchievements(newAchievements);
          setShowAchievementToast(newAchievements[index]);
          soundManager.playSuccessChime();
          setTimeout(() => setShowAchievementToast(null), 5000);
        }
      }
    });
  }, [statistics, achievements]);

  // Helper function to add log entry
  const addLog = (message: string, type: LogEntry['type']) => {
    const hours = Math.floor(gameTime / 60);
    const minutes = Math.floor(gameTime % 60);
    const timestamp = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;

    setLogs((prev) => {
      const newLogs = [
        ...prev,
        {
          id: logCounter,
          timestamp,
          message,
          type,
        },
      ];
      return newLogs.slice(-50);
    });
    setLogCounter((prev) => prev + 1);
  };

  // Get difficulty settings (lstsim.de style - realistic balance)
  const getDifficultySettings = () => {
    switch (difficulty) {
      case 'Leicht':
        return {
          vehicleCount: 6,
          vehicleTypes: ['Streifenwagen', 'Streifenwagen', 'Streifenwagen', 'Streifenwagen', 'SEK', 'Zivilfahrzeug'] as VehicleType[],
          incidentsPerHour: 1.5,  // 1.5 Eins√§tze pro Stunde
          maxIncidents: 2,
          baseTimeLimit: 90,
        };
      case 'Schwer':
        return {
          vehicleCount: 4,
          vehicleTypes: ['Streifenwagen', 'Streifenwagen', 'SEK', 'Polizeihubschrauber'] as VehicleType[],
          incidentsPerHour: 3.5,  // 3.5 Eins√§tze pro Stunde
          maxIncidents: 4,
          baseTimeLimit: 45,
        };
      default: // Mittel
        return {
          vehicleCount: 5,
          vehicleTypes: ['Streifenwagen', 'Streifenwagen', 'Streifenwagen', 'SEK', 'Zivilfahrzeug'] as VehicleType[],
          incidentsPerHour: 2.5,  // 2.5 Eins√§tze pro Stunde (lstsim.de Standard)
          maxIncidents: 3,
          baseTimeLimit: 60,
        };
    }
  };

  // Initialize vehicles for selected station
  const startGame = (stationId: number) => {
    const station = policeStations.find(s => s.id === stationId);
    if (!station) return;

    setSelectedStation(stationId);
    setMapCenter(station.position);
    setGameTime(selectedTime * 60);

    const settings = getDifficultySettings();
    const newVehicles: Vehicle[] = [];

    for (let i = 0; i < settings.vehicleCount; i++) {
      const vehicleType = settings.vehicleTypes[i] || 'Streifenwagen';
      newVehicles.push({
        id: i + 1,
        stationId,
        position: station.position,
        assignedIncidentId: null,
        routeIndex: 0,
        route: null,
        routeProgress: 0,
        bearing: 0,
        routeDuration: 0,
        routeStartTime: 0,
        totalDistanceTraveled: 0,
        isAvailable: true,
        status: 'S1', // Bereit an Wache
        processingStartTime: null,
        processingDuration: 0,
        // NEU: Fahrzeugtyp-spezifische Eigenschaften
        vehicleType: vehicleType,
        speakRequest: null,
        outOfServiceReason: null,
        outOfServiceUntil: null,
        canBeRedirected: true, // lstsim.de: S8-Fahrzeuge k√∂nnen umgeleitet werden
      });
    }

    setVehicles(newVehicles);
    setGameStarted(true);

    addLog(`Schicht begonnen in ${station.name}`, 'new');
    setTimeout(() => generateIncident(), 2000);
  };

  // NEW: Generate random call (instead of incident directly) - LST SIM Style mit Gespr√§chstext
  const generateCall = () => {
    const location = frankfurtLocations[Math.floor(Math.random() * frankfurtLocations.length)];
    const hour = Math.floor(gameTime / 60);
    const incidentType = getWeightedIncidentType(hour); // Gewichtete Auswahl

    // Hole realistischen Gespr√§chstext f√ºr diesen Einsatztyp
    const callTextData = getRandomCallText(incidentType.type);
    const hasCallbackNumber = Math.random() < 0.7; // 70% haben R√ºckrufnummer

    const newCall: Call = {
      id: callIdCounter,
      type: incidentType.type,
      position: location.position as [number, number],
      priority: incidentType.priority as 'low' | 'medium' | 'high',
      description: incidentType.description,
      locationName: location.name,
      timestamp: Date.now(),
      answered: false,
      // NEU: LST SIM Style Eigenschaften
      callerText: callTextData.text,
      callerType: callTextData.callerType,
      callerName: callTextData.callerName,
      callbackNumber: hasCallbackNumber ? generateCallbackNumber() : undefined,
      status: 'waiting',
    };

    setCalls(prev => [...prev, newCall]);
    setCallIdCounter(prev => prev + 1);

    setToasts((prev) => [
      ...prev,
      {
        id: toastCounter,
        type: `Anruf: ${incidentType.type}`,
        location: location.name,
        priority: incidentType.priority as 'low' | 'medium' | 'high',
        incidentId: callIdCounter,
      },
    ]);
    setToastCounter((prev) => prev + 1);

    if (incidentType.priority === 'high') {
      soundManager.playAlertSound();
    }

    addLog(`Notruf eingehend: ${incidentType.type} in ${location.name}`, 'new');
  };

  // NEU: √ñffne Call-Modal zum Anrufer-Gespr√§ch
  const openCallModal = (callId: number) => {
    const call = calls.find(c => c.id === callId);
    if (!call) return;

    setSelectedCall(call);
    setIsCallModalOpen(true);
    soundManager.playSirenBeep();
  };

  // NEU: Lehne Anruf ab (Auflegen)
  const rejectCall = (callId: number) => {
    setCalls(prev => prev.map(c =>
      c.id === callId ? { ...c, status: 'rejected' as const, answered: true } : c
    ));
    addLog(`Anruf abgelehnt: ${calls.find(c => c.id === callId)?.type || 'Unbekannt'}`, 'failed');

    // Entferne abgelehnte Anrufe nach 3 Sekunden
    setTimeout(() => {
      setCalls(prev => prev.filter(c => c.id !== callId));
    }, 3000);
  };

  // NEW: Accept call and create incident (nur noch aus Modal heraus aufrufbar)
  const acceptCall = (callId: number) => {
    const call = calls.find(c => c.id === callId);
    if (!call) return;

    const settings = getDifficultySettings();
    const incidentType = incidentTypes.find(it => it.type === call.type);
    if (!incidentType) return;

    // Eskalationslogik: 10% Chance, kann eskalieren
    const canEscalate = escalationRules[call.type] !== undefined && Math.random() < 0.1;
    const escalationDelay = canEscalate ? 60 + Math.random() * 30 : 0; // 60-90 Sekunden

    const newIncident: Incident = {
      id: incidentCounter,
      type: call.type,
      position: call.position,
      assignedVehicleIds: [],
      priority: call.priority,
      description: `${call.description} - ${call.locationName}`,
      timeRemaining: settings.baseTimeLimit,
      locationName: call.locationName,
      spawnTime: Date.now(),
      requiredVehicles: incidentType.requiredVehicles,
      arrivedVehicles: 0,
      processingDuration: incidentProcessingTimes[call.type] || 180,
      canEscalate: canEscalate,
      escalationTime: canEscalate ? Date.now() + escalationDelay * 1000 : null,
      hasEscalated: false,
    };

    setIncidents(prev => [...prev, newIncident]);
    setIncidentCounter(prev => prev + 1);

    // Markiere Call als "answered" und entferne nach kurzer Verz√∂gerung
    setCalls(prev => prev.map(c =>
      c.id === callId ? { ...c, status: 'answered' as const, answered: true } : c
    ));

    // Entferne angenommene Anrufe nach 2 Sekunden
    setTimeout(() => {
      setCalls(prev => prev.filter(c => c.id !== callId));
    }, 2000);

    soundManager.playSirenBeep();
    addLog(`Anruf entgegengenommen: ${call.type} in ${call.locationName} ‚Üí Einsatz #${incidentCounter}`, 'assignment');
  };

  // BUGFIX: generateIncident jetzt direkt als generateCall (lstsim.de Style)
  const generateIncident = () => {
    generateCall(); // Nutze Call-System wie lstsim.de
  };

  // Request backup - adds an extra vehicle temporarily
  const requestBackup = (incidentId: number) => {
    const incident = incidents.find(i => i.id === incidentId);
    if (!incident) return;

    addLog(`Verst√§rkung angefordert f√ºr ${incident.type} in ${incident.locationName}`, 'assignment');
    soundManager.playSirenBeep();

    // Increase required vehicles by 1
    setIncidents(prev =>
      prev.map(i =>
        i.id === incidentId
          ? { ...i, requiredVehicles: i.requiredVehicles + 1, timeRemaining: i.timeRemaining + 20 }
          : i
      )
    );
  };

  // Assign vehicle to incident (mit Error Handling f√ºr OSRM + lstsim.de S8-Umleitung)
  const assignVehicle = async (vehicleId: number, incidentId: number) => {
    const vehicle = vehicles.find(v => v.id === vehicleId);
    const incident = incidents.find(i => i.id === incidentId);

    // BUGFIX lstsim.de: S8-Fahrzeuge K√ñNNEN umgeleitet werden! (nur S1 + S8 erlaubt)
    const canAssign = vehicle && (vehicle.status === 'S1' || (vehicle.status === 'S8' && vehicle.canBeRedirected));

    if (!vehicle || !incident || !canAssign || incident.assignedVehicleIds.includes(vehicleId)) {
      return;
    }

    // Wenn Fahrzeug in S8 ist, von altem Einsatz entfernen
    if (vehicle.status === 'S8' && vehicle.assignedIncidentId) {
      setIncidents(prev =>
        prev.map(i =>
          i.id === vehicle.assignedIncidentId
            ? { ...i, assignedVehicleIds: i.assignedVehicleIds.filter(vid => vid !== vehicleId) }
            : i
        )
      );
      addLog(`S-${vehicleId.toString().padStart(2, '0')} S8‚ÜíS3 Umgeleitet zu neuem Einsatz`, 'assignment');
    }

    const station = policeStations.find(s => s.id === vehicle.stationId);
    if (!station) return;

    let route: [number, number][] | null = null;
    let routeDuration = 240;
    let routeDistance = 0;

    try {
      const osrmRoute = await getRoute(
        { lat: vehicle.position[0], lng: vehicle.position[1] },
        { lat: incident.position[0], lng: incident.position[1] }
      );

      if (osrmRoute) {
        route = convertToLeafletFormat(osrmRoute.coordinates);
        routeDistance = osrmRoute.distance;
        routeDuration = osrmRoute.duration * 0.7;
      } else {
        route = getStraightLineRoute(
          { lat: vehicle.position[0], lng: vehicle.position[1] },
          { lat: incident.position[0], lng: incident.position[1] }
        );
        routeDistance = calculateDistance(
          { lat: vehicle.position[0], lng: vehicle.position[1] },
          { lat: incident.position[0], lng: incident.position[1] }
        );
        routeDuration = Math.max(60, routeDistance / 20);
      }
    } catch (error) {
      console.error('OSRM Routing Fehler:', error);
      // Toast-Benachrichtigung bei OSRM-Fehler
      setToasts((prev) => [
        ...prev,
        {
          id: toastCounter,
          type: 'Routing Fehler',
          location: 'OSRM Server nicht erreichbar - Verwende Direktroute',
          priority: 'high',
          incidentId: 0,
        },
      ]);
      setToastCounter((prev) => prev + 1);

      // Fallback: Straight Line Route
      route = getStraightLineRoute(
        { lat: vehicle.position[0], lng: vehicle.position[1] },
        { lat: incident.position[0], lng: incident.position[1] }
      );
      routeDistance = calculateDistance(
        { lat: vehicle.position[0], lng: vehicle.position[1] },
        { lat: incident.position[0], lng: incident.position[1] }
      );
      routeDuration = Math.max(60, routeDistance / 20);
    }

    const routeStartTime = Date.now();

    setVehicles(prev =>
      prev.map(v =>
        v.id === vehicleId ? {
          ...v,
          assignedIncidentId: incidentId,
          routeIndex: 0,
          route,
          routeProgress: 0,
          bearing: 0,
          routeDuration,
          routeStartTime,
          status: 'S3', // Anfahrt zum Einsatz
        } : v
      )
    );

    setIncidents(prev =>
      prev.map(i =>
        i.id === incidentId ? { ...i, assignedVehicleIds: [...i.assignedVehicleIds, vehicleId] } : i
      )
    );

    soundManager.playSirenBeep();
    // OPTIMIERUNG 2: Protocol-Log detaillierter (lstsim.de Style)
    addLog(`S-${vehicleId.toString().padStart(2, '0')} S1‚ÜíS3 Einsatz #${incidentId} ${incident.type}`, 'assignment');
  };

  // Vehicle movement animation and status management (Performance-Optimierung: nur wenn Fahrzeuge bewegt werden)
  useEffect(() => {
    if (!gameStarted) return;

    let animationFrameId: number;

    const animate = () => {
      // Performance-Check: Nur animieren wenn Fahrzeuge tats√§chlich unterwegs sind
      const hasMovingVehicles = vehicles.some(v => v.status === 'S3' || v.status === 'S8');

      if (!hasMovingVehicles) {
        // Keine Fahrzeuge unterwegs - kein neuer Frame
        return;
      }

      setVehicles(prev =>
        prev.map(vehicle => {
          // S1: Bereit an Wache - no action needed
          if (vehicle.status === 'S1') {
            return vehicle;
          }

          // S3: Anfahrt zum Einsatz
          if (vehicle.status === 'S3' && vehicle.route) {
            const currentTime = Date.now();
            const timeElapsed = (currentTime - vehicle.routeStartTime) / 1000;
            const newProgress = Math.min(timeElapsed / vehicle.routeDuration, 1);

            if (newProgress >= 1) {
              // Arrived at incident - change to S4
              const incident = incidents.find(i => i.id === vehicle.assignedIncidentId);

              // Berechne Parking-Position: Fahrzeuge nebeneinander statt √ºbereinander
              const incidentVehicles = prev.filter(v =>
                v.assignedIncidentId === vehicle.assignedIncidentId && v.status === 'S4'
              );
              const parkingIndex = incidentVehicles.length; // Wieviele Fahrzeuge sind schon da?

              // Erstelle einen kleinen Offset um den Einsatzort herum (in einem Halbkreis)
              const incidentPos = vehicle.route[vehicle.route.length - 1];
              const offsetDistance = 0.0001; // ~11 Meter Abstand
              const angleStep = Math.PI / 4; // 45 Grad zwischen Fahrzeugen
              const angle = -Math.PI / 2 + (parkingIndex * angleStep); // Startwinkel -90¬∞ (oben)

              const parkedPosition: [number, number] = [
                incidentPos[0] + (Math.sin(angle) * offsetDistance),
                incidentPos[1] + (Math.cos(angle) * offsetDistance)
              ];

              setIncidents(prevIncidents =>
                prevIncidents.map(inc =>
                  inc.id === vehicle.assignedIncidentId
                    ? { ...inc, arrivedVehicles: inc.arrivedVehicles + 1 }
                    : inc
                )
              );

              // OPTIMIERUNG 2: Protocol-Log detaillierter (lstsim.de Style)
              addLog(`S-${vehicle.id.toString().padStart(2, '0')} S3‚ÜíS4 Einsatzort erreicht`, 'arrival');

              return {
                ...vehicle,
                position: parkedPosition, // Geparkte Position mit Offset
                status: 'S4', // Am Einsatzort
                processingStartTime: Date.now(),
                processingDuration: incident?.processingDuration || 180,
                routeProgress: 1,
              };
            }

            const { position: newPosition, bearing: newBearing } = getPointAlongRoute(vehicle.route, newProgress);

            return {
              ...vehicle,
              position: newPosition,
              routeProgress: newProgress,
              bearing: newBearing,
            };
          }

          // S4: Am Einsatzort - wait for processing to complete
          if (vehicle.status === 'S4' && vehicle.processingStartTime) {
            // Processing is handled in separate useEffect
            return vehicle;
          }

          // S8: R√ºckfahrt zur Wache
          if (vehicle.status === 'S8' && vehicle.route) {
            const currentTime = Date.now();
            const timeElapsed = (currentTime - vehicle.routeStartTime) / 1000;
            const newProgress = Math.min(timeElapsed / vehicle.routeDuration, 1);

            if (newProgress >= 1) {
              // Arrived at station - change to S1
              const station = policeStations.find(s => s.id === vehicle.stationId);

              const routeDistance = vehicle.route?.length
                ? vehicle.route.reduce((total, point, index) => {
                    if (index === 0) return 0;
                    const prev = vehicle.route![index - 1];
                    return total + calculateDistance(
                      { lat: prev[0], lng: prev[1] },
                      { lat: point[0], lng: point[1] }
                    );
                  }, 0)
                : 0;

              // OPTIMIERUNG 2: Protocol-Log detaillierter (lstsim.de Style)
              addLog(`S-${vehicle.id.toString().padStart(2, '0')} S8‚ÜíS1 An Wache`, 'completion');

              return {
                ...vehicle,
                position: station ? station.position : vehicle.position,
                assignedIncidentId: null,
                routeIndex: 0,
                route: null,
                routeProgress: 0,
                bearing: 0,
                routeDuration: 0,
                routeStartTime: 0,
                status: 'S1', // Bereit an Wache
                processingStartTime: null,
                processingDuration: 0,
                totalDistanceTraveled: vehicle.totalDistanceTraveled + routeDistance,
              };
            }

            const { position: newPosition, bearing: newBearing } = getPointAlongRoute(vehicle.route, newProgress);

            return {
              ...vehicle,
              position: newPosition,
              routeProgress: newProgress,
              bearing: newBearing,
            };
          }

          return vehicle;
        })
      );

      animationFrameId = requestAnimationFrame(animate);
    };

    // Starte Animation nur wenn Fahrzeuge tats√§chlich unterwegs sind
    const hasMovingVehicles = vehicles.some(v => v.status === 'S3' || v.status === 'S8');
    if (hasMovingVehicles) {
      animationFrameId = requestAnimationFrame(animate);
    }

    return () => {
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
      }
    };
  }, [gameStarted, incidents, vehicles]);

  // Handle S4 processing and transition to S8 (Optimierung: nur wenn Fahrzeuge am Einsatzort sind)
  useEffect(() => {
    if (!gameStarted) return;

    // Performance-Check: Nur laufen wenn Fahrzeuge Status S4 haben
    const hasProcessingVehicles = vehicles.some(v => v.status === 'S4');
    if (!hasProcessingVehicles) return;

    const interval = setInterval(() => {
      setVehicles(prev =>
        prev.map(vehicle => {
          if (vehicle.status === 'S4' && vehicle.processingStartTime) {
            const currentTime = Date.now();
            const processingElapsed = (currentTime - vehicle.processingStartTime) / 1000;

            if (processingElapsed >= vehicle.processingDuration) {
              // Check if all required vehicles have arrived and processed
              const incident = incidents.find(i => i.id === vehicle.assignedIncidentId);
              if (incident && incident.arrivedVehicles >= incident.requiredVehicles) {
                // All vehicles ready - start return trip
                const station = policeStations.find(s => s.id === vehicle.stationId);
                if (!station) return vehicle;

                // Get route back to station
                getRoute(
                  { lat: vehicle.position[0], lng: vehicle.position[1] },
                  { lat: station.position[0], lng: station.position[1] }
                ).then(osrmRoute => {
                  let returnRoute: [number, number][] | null = null;
                  let returnDuration = 240;

                  if (osrmRoute) {
                    returnRoute = convertToLeafletFormat(osrmRoute.coordinates);
                    returnDuration = osrmRoute.duration * 0.7;
                  } else {
                    returnRoute = getStraightLineRoute(
                      { lat: vehicle.position[0], lng: vehicle.position[1] },
                      { lat: station.position[0], lng: station.position[1] }
                    );
                    const returnDistance = calculateDistance(
                      { lat: vehicle.position[0], lng: vehicle.position[1] },
                      { lat: station.position[0], lng: station.position[1] }
                    );
                    returnDuration = Math.max(60, returnDistance / 20);
                  }

                  setVehicles(prevVehicles =>
                    prevVehicles.map(v =>
                      v.id === vehicle.id
                        ? {
                            ...v,
                            status: 'S8', // R√ºckfahrt zur Wache
                            route: returnRoute,
                            routeProgress: 0,
                            routeStartTime: Date.now(),
                            routeDuration: returnDuration,
                          }
                        : v
                    )
                  );

                  // OPTIMIERUNG 2: Protocol-Log detaillierter (lstsim.de Style)
                  addLog(`S-${vehicle.id.toString().padStart(2, '0')} S4‚ÜíS8 R√ºckkehr zur Wache`, 'completion');
                });
              }

              return vehicle;
            }
          }

          return vehicle;
        })
      );
    }, 1000);

    return () => clearInterval(interval);
  }, [gameStarted, incidents, vehicles]);

  // Eskalations-System (Optimierung: nur wenn eskalationsf√§hige Eins√§tze vorhanden sind)
  useEffect(() => {
    if (!gameStarted) return;

    // Performance-Check: Nur laufen wenn eskalationsf√§hige Eins√§tze vorhanden sind
    const hasEscalatableIncidents = incidents.some(i => i.canEscalate && !i.hasEscalated);
    if (!hasEscalatableIncidents) return;

    const interval = setInterval(() => {
      setIncidents(prev =>
        prev.map(incident => {
          // Pr√ºfe ob Einsatz eskalieren soll
          if (
            incident.canEscalate &&
            !incident.hasEscalated &&
            incident.escalationTime &&
            Date.now() >= incident.escalationTime &&
            incident.assignedVehicleIds.length > 0 && // Nur wenn Fahrzeuge unterwegs
            (vehicles.some(v => v.assignedIncidentId === incident.id && (v.status === 'S3' || v.status === 'S4')))
          ) {
            const escalation = escalationRules[incident.type];
            if (escalation) {
              const newType = escalation.newType;
              const newPriority = escalation.newPriority;
              const escalatedIncidentType = incidentTypes.find(it => it.type === newType);

              if (escalatedIncidentType) {
                // Eskalations-Benachrichtigung
                soundManager.playAlertSound();
                addLog(`‚ö†Ô∏è ESKALATION: ${incident.type} ‚Üí ${newType} in ${incident.locationName}`, 'new');

                setToasts((prevToasts) => [
                  ...prevToasts,
                  {
                    id: toastCounter,
                    type: `‚ö†Ô∏è ESKALATION: ${newType}`,
                    location: incident.locationName,
                    priority: newPriority,
                    incidentId: incident.id,
                  },
                ]);
                setToastCounter((prev) => prev + 1);

                // Aktualisiere Einsatz
                return {
                  ...incident,
                  type: newType,
                  priority: newPriority,
                  description: `${escalatedIncidentType.description} - ${incident.locationName}`,
                  requiredVehicles: incident.requiredVehicles + 1,
                  timeRemaining: incident.timeRemaining + 30,
                  processingDuration: incidentProcessingTimes[newType] || incident.processingDuration,
                  hasEscalated: true,
                  canEscalate: false,
                };
              }
            }
          }

          return incident;
        })
      );
    }, 1000);

    return () => clearInterval(interval);
  }, [gameStarted, vehicles, incidents]);

  // Incident completion check (Optimierung: nur wenn aktive Eins√§tze vorhanden sind)
  useEffect(() => {
    if (!gameStarted) return;

    // Performance-Check: Nur laufen wenn Eins√§tze vorhanden sind
    if (incidents.length === 0) return;

    const interval = setInterval(() => {
      setIncidents(prev => {
        const updated = prev.map(incident => {
          // Check if all required vehicles have arrived
          if (incident.arrivedVehicles >= incident.requiredVehicles) {
            // KRITISCHER BUGFIX (lstsim.de Style): Einsatz ist ERST abgeschlossen wenn ALLE Fahrzeuge in S8 sind!
            const incidentVehicles = vehicles.filter(v => v.assignedIncidentId === incident.id);
            const allReturning = incidentVehicles.every(v => v.status === 'S8');

            if (allReturning && incidentVehicles.length > 0) {
              // All vehicles are returning - complete incident
              const responseTime = (Date.now() - incident.spawnTime) / 1000;
              const points = incident.priority === 'high' ? 30 : incident.priority === 'medium' ? 20 : 10;
              const bonus = incident.requiredVehicles > 1 ? incident.requiredVehicles * 10 : 0;

              setScore(s => s + points + bonus);

              setStatistics(prev => ({
                ...prev,
                totalResolved: prev.totalResolved + 1,
                totalResponseTimes: [...prev.totalResponseTimes, responseTime],
                incidentsByType: {
                  ...prev.incidentsByType,
                  [incident.type]: (prev.incidentsByType[incident.type] || 0) + 1,
                },
                currentStreak: prev.currentStreak + 1,
                bestStreak: Math.max(prev.bestStreak, prev.currentStreak + 1),
                totalDistance: prev.totalDistance + vehicles.reduce((sum, v) => sum + v.totalDistanceTraveled, 0),
              }));

              soundManager.playSuccessChime();
              addLog(`Einsatz ${incident.type} in ${incident.locationName} erfolgreich abgeschlossen (+${points + bonus} Punkte)`, 'completion');

              return null;
            }
          }

          // Decrement timer if not all vehicles assigned
          if (incident.assignedVehicleIds.length < incident.requiredVehicles) {
            return { ...incident, timeRemaining: incident.timeRemaining - 1 };
          }

          return incident;
        }).filter(i => {
          if (i === null) return false;
          if (i.timeRemaining <= 0) {
            setStatistics(prev => ({
              ...prev,
              totalFailed: prev.totalFailed + 1,
              currentStreak: 0,
            }));
            soundManager.playFailureSound();
            addLog(`Einsatz ${i.type} in ${i.locationName} fehlgeschlagen (Zeit abgelaufen)`, 'failed');
            return false;
          }
          return true;
        }) as Incident[];

        return updated;
      });
    }, 1000);

    return () => clearInterval(interval);
  }, [gameStarted, vehicles]);

  // Generate new incidents periodically (lstsim.de style: based on incidents per hour)
  // BUGFIX: Memory Leak behoben - setTimeout Cleanup hinzugef√ºgt
  useEffect(() => {
    if (!gameStarted) return;

    const settings = getDifficultySettings();
    let isCancelled = false; // Flag um Timeout-Kette zu stoppen
    const timeouts: ReturnType<typeof setTimeout>[] = []; // Array f√ºr alle aktiven Timeouts

    // lstsim.de: Berechne Intervall basierend auf Eins√§tzen pro Stunde
    // Formel: (3600 Sekunden / Eins√§tze pro Stunde) √ó Zufallsfaktor (0.7-1.3)
    const baseInterval = (3600 / settings.incidentsPerHour) * 1000; // In Millisekunden

    const scheduleNextIncident = () => {
      if (isCancelled) return; // Stoppe wenn cancelled

      // Rush hour multiplier (7-9 Uhr und 17-19 Uhr)
      const hour = Math.floor(gameTime / 60);
      const isRushHour = (hour >= 7 && hour <= 9) || (hour >= 17 && hour <= 19);
      const rushHourMultiplier = isRushHour ? 0.7 : 1; // Mehr Eins√§tze = k√ºrzeres Intervall

      // Zuf√§lliger Faktor f√ºr Variation (0.7-1.3)
      const randomFactor = 0.7 + Math.random() * 0.6;

      // Berechne n√§chstes Intervall
      const nextInterval = baseInterval * rushHourMultiplier * randomFactor;

      const timeout = setTimeout(() => {
        if (!isCancelled && incidents.length < settings.maxIncidents) {
          generateIncident();
        }
        scheduleNextIncident(); // Schedule next incident
      }, nextInterval);

      timeouts.push(timeout);
    };

    // Start initial incident schedule
    const initialDelay = baseInterval * (0.3 + Math.random() * 0.4); // 30-70% of base interval
    const initialTimeout = setTimeout(() => {
      if (!isCancelled) {
        generateIncident();
        scheduleNextIncident();
      }
    }, initialDelay);

    timeouts.push(initialTimeout);

    // Cleanup: Stoppe alle Timeouts wenn Component unmounted oder gameStarted sich √§ndert
    return () => {
      isCancelled = true;
      timeouts.forEach(timeout => clearTimeout(timeout));
    };
  }, [gameStarted]);

  // Game time progression (mit Geschwindigkeit und Pause)
  useEffect(() => {
    if (!gameStarted || isPaused) return;

    // Intervall basierend auf Geschwindigkeit: 10s (1x), 5s (2x), 3.33s (3x), 2.5s (4x)
    const baseInterval = 10000 / gameSpeed;

    const interval = setInterval(() => {
      setGameTime((prev) => prev + 1);
    }, baseInterval);

    return () => clearInterval(interval);
  }, [gameStarted, gameSpeed, isPaused]);

  // Update call timers every second for live countdown
  useEffect(() => {
    const interval = setInterval(() => {
      setCurrentTime(Date.now());
    }, 1000);
    return () => clearInterval(interval);
  }, []);

  // Get status badge color and text (lstsim.de Style - ERWEITERT)
  const getStatusBadge = (status: VehicleStatus) => {
    const badges = {
      'S1': { color: '#30D158', text: 'S1 Bereit', short: 'S1' },
      'S3': { color: '#FF9F0A', text: 'S3 Anfahrt', short: 'S3' },
      'S4': { color: '#FF453A', text: 'S4 Einsatzort', short: 'S4' },
      'S5': { color: '#0A84FF', text: 'S5 Sprechwunsch', short: 'S5' },
      'S6': { color: '#8E8E93', text: 'S6 Au√üer Dienst', short: 'S6' },
      'S8': { color: '#0A84FF', text: 'S8 R√ºckfahrt', short: 'S8' },
    };
    return badges[status];
  };

  if (!gameStarted) {
    return (
      <div className="station-selection">
        <div className="start-screen-header">
          <img src="/polizeistern-hessen.svg" alt="Polizeistern Hessen" width="80" height="80" />
          <h1>Einsatzleitung Frankfurt</h1>
          <p className="subtitle">W√§hle deine Polizeiwache</p>
        </div>

        <div className="game-settings">
          <div className="setting-group">
            <label>Schwierigkeit</label>
            <div className="difficulty-buttons">
              <button
                className={`difficulty-btn ${difficulty === 'Leicht' ? 'active' : ''}`}
                onClick={() => setDifficulty('Leicht')}
              >
                Leicht
              </button>
              <button
                className={`difficulty-btn ${difficulty === 'Mittel' ? 'active' : ''}`}
                onClick={() => setDifficulty('Mittel')}
              >
                Mittel
              </button>
              <button
                className={`difficulty-btn ${difficulty === 'Schwer' ? 'active' : ''}`}
                onClick={() => setDifficulty('Schwer')}
              >
                Schwer
              </button>
            </div>
          </div>

          <div className="setting-group">
            <label>Schichtbeginn</label>
            <select
              className="time-select"
              value={selectedTime}
              onChange={(e) => setSelectedTime(Number(e.target.value))}
            >
              {Array.from({ length: 24 }, (_, i) => (
                <option key={i} value={i}>
                  {i.toString().padStart(2, '0')}:00 Uhr
                </option>
              ))}
            </select>
          </div>
        </div>

        <div className="station-grid">
          {policeStations.map(station => (
            <div
              key={station.id}
              className="station-card"
              onClick={() => startGame(station.id)}
            >
              <img className="station-icon-large" src="/polizeistern-hessen.svg" alt="Polizeirevier" width="56" height="56" />
              <h3>{station.name}</h3>
              <p>Klicken zum Starten</p>
            </div>
          ))}
        </div>

        {achievements.filter(a => a.unlocked).length > 0 && (
          <div className="achievements-section">
            <h3 className="achievements-title">
              Erfolge {achievements.filter(a => a.unlocked).length}/{achievements.length}
            </h3>
            <div className="achievements-grid">
              {achievements.map(achievement => (
                <div
                  key={achievement.id}
                  className={`achievement-badge ${achievement.unlocked ? 'unlocked' : 'locked'}`}
                  title={achievement.description}
                >
                  <span style={{ fontSize: '24px' }}>{achievement.icon}</span>
                </div>
              ))}
            </div>
          </div>
        )}
      </div>
    );
  }

  const selectedStationData = policeStations.find(s => s.id === selectedStation);

  const hours = Math.floor(gameTime / 60);
  const minutes = Math.floor(gameTime % 60);
  const formattedTime = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;

  // Bestimme Tageszeit-Icon
  const getTimeOfDayIcon = (hour: number) => {
    if (hour >= 20 || hour < 6) return ''; // Nacht
    if ((hour >= 6 && hour < 8) || (hour >= 18 && hour < 20)) return ''; // D√§mmerung
    return ''; // Tag
  };

  // Count vehicles by status for filter display
  const vehicleStatusCounts = {
    S1: vehicles.filter(v => v.status === 'S1').length,
    S3: vehicles.filter(v => v.status === 'S3').length,
    S4: vehicles.filter(v => v.status === 'S4').length,
  };

  return (
    <div className="app">
      {/* NEW LAYOUT: Map on left, right panel split into vehicles (top) and calls (bottom) */}
      <div className="main-layout">
        {/* LEFT: Full Map */}
        <div className="map-container">
          {/* Tag/Nacht-Overlay */}
          <div
            className="map-overlay"
            style={{
              opacity: getMapOverlayOpacity(Math.floor(gameTime / 60)),
            }}
          />

          <MapContainer
            center={mapCenter}
            zoom={13}
            style={{ height: '100%', width: '100%' }}
          >
            <MapCenterUpdater center={mapCenter} />
            <TileLayer
              attribution='&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
              url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
            />

            {policeStations.map(station => (
              <Marker
                key={station.id}
                position={station.position}
                icon={createStationIcon()}
              >
                <Popup>{station.name}</Popup>
              </Marker>
            ))}

            {incidents.map(incident => (
              <Marker
                key={incident.id}
                position={incident.position}
                icon={createIncidentIcon(incident.priority, incident.hasEscalated)}
              >
                <Popup>
                  <strong>{incident.type}</strong>
                  {incident.hasEscalated && <span style={{ color: '#FF453A', marginLeft: '8px' }}>‚ö†Ô∏è ESKALIERT</span>}
                  <br />
                  {incident.description}
                  <br />
                  Zeit: {incident.timeRemaining}s
                  <br />
                  Bearbeitung: {Math.floor(incident.processingDuration / 60)} Min
                </Popup>
              </Marker>
            ))}

            {vehicles
              .filter(vehicle => vehicle.status !== 'S1') // Hide parked vehicles
              .map(vehicle => {
              return (
                <React.Fragment key={vehicle.id}>
                  <VehicleMarker
                    position={vehicle.position}
                    bearing={vehicle.bearing}
                    status={vehicle.status}
                    vehicle={vehicle}
                  />

                  {vehicle.route && vehicle.route.length > 0 && (
                    <Polyline
                      positions={vehicle.route}
                      color={vehicle.status === 'S3' ? '#FF453A' : '#0A84FF'} // Rot f√ºr Hinfahrt, Blau f√ºr R√ºckfahrt
                      weight={4}
                      opacity={0.7}
                    />
                  )}
                </React.Fragment>
              );
            })}
          </MapContainer>
        </div>

        {/* RIGHT: Three-Column Layout wie lstsim.de */}
        <div className="right-panel-lstsim">
          {/* LEFT COLUMN: Fahrzeuge */}
          <div className="vehicle-list-panel">
            <div className="panel-header">
              <h3>Fahrzeuge</h3>
              <div className="vehicle-filters">
                <button className="filter-btn">{vehicleStatusCounts.S1}</button>
                <button className="filter-btn">{vehicleStatusCounts.S3}</button>
                <button className="filter-btn">{vehicleStatusCounts.S4}</button>
              </div>
            </div>
            <div className="panel-content">
              {[...vehicles]
                .sort((a, b) => {
                  const statusOrder: { [key in VehicleStatus]: number } = { S1: 1, S3: 2, S4: 3, S8: 4 };
                  return statusOrder[a.status] - statusOrder[b.status];
                })
                .map(vehicle => {
                  const statusInfo = getStatusBadge(vehicle.status);
                  const incident = incidents.find(i => i.id === vehicle.assignedIncidentId);
                  const vehicleConfig = vehicleTypeConfigs[vehicle.vehicleType];

                  return (
                    <div
                      key={vehicle.id}
                      className={`vehicle-list-item ${selectedVehicleId === vehicle.id ? 'selected' : ''}`}
                      onClick={() => {
                        setMapCenter(vehicle.position);
                        setSelectedVehicleId(vehicle.id);
                        soundManager.playSirenBeep();
                      }}
                    >
                      <div className="vehicle-list-left">
                        <span className="vehicle-icon">{vehicleConfig.icon}</span>
                        <span className="vehicle-name">{vehicleConfig.displayName} {vehicle.id}</span>
                        <span className="vehicle-status-icon" style={{ background: statusInfo.color }}></span>
                      </div>
                      {incident && (
                        <div className="vehicle-list-incident">
                          {incident.type} ‚Ä¢ {incident.locationName}
                        </div>
                      )}
                      {vehicle.status === 'S8' && vehicle.canBeRedirected && (
                        <div className="vehicle-redirect-hint">‚Üª Kann umgeleitet werden</div>
                      )}
                    </div>
                  );
                })}
            </div>
          </div>

          {/* MIDDLE COLUMN: Eins√§tze (lstsim.de Style) */}
          <div className="incidents-panel-lstsim">
            <div className="panel-header">
              <h3>Aktive Eins√§tze ({incidents.length})</h3>
            </div>
            <div className="panel-content">
              {incidents.length === 0 && (
                <div className="empty-state">Keine aktiven Eins√§tze</div>
              )}
              {incidents.map(incident => {
                const minETA = calculateMinETA(incident, vehicles);
                const assignedVehicles = vehicles.filter(v => incident.assignedVehicleIds.includes(v.id));
                const availableVehicles = vehicles.filter(v => v.status === 'S1' || (v.status === 'S8' && v.canBeRedirected));

                return (
                  <div key={incident.id} className={`incident-card-lstsim priority-${incident.priority}`}>
                    <div className="incident-card-header">
                      <div className="incident-card-title">
                        {incident.hasEscalated && <span className="escalation-badge">!</span>}
                        <strong>{incident.type}</strong>
                        <span className={`priority-badge-lstsim priority-${incident.priority}`}>
                          {incident.priority === 'high' ? 'DRINGEND' : incident.priority === 'medium' ? 'NORMAL' : 'NIEDRIG'}
                        </span>
                      </div>
                      <span className="time-remaining-large">{incident.timeRemaining}s</span>
                    </div>

                    <div className="incident-location-lstsim">
                      {incident.locationName}
                    </div>

                    <div className="incident-status-row">
                      <span>Fahrzeuge: {incident.arrivedVehicles}/{incident.requiredVehicles}</span>
                      {minETA > 0 && <span>ETA: {Math.ceil(minETA)} Min</span>}
                      <button
                        className="map-center-btn"
                        onClick={() => setMapCenter(incident.position)}
                        title="Auf Karte zentrieren und heranzoomen"
                      >
                        ‚äï
                      </button>
                    </div>

                    {/* Zugewiesene Fahrzeuge */}
                    {assignedVehicles.length > 0 && (
                      <div className="assigned-vehicles-list">
                        {assignedVehicles.map(v => {
                          const config = vehicleTypeConfigs[v.vehicleType];
                          const statusInfo = getStatusBadge(v.status);
                          return (
                            <div key={v.id} className="assigned-vehicle-chip">
                              {config.icon} {v.id} <span style={{color: statusInfo.color}}>‚óè</span>
                            </div>
                          );
                        })}
                      </div>
                    )}

                    {/* Fahrzeugzuweisung */}
                    {incident.assignedVehicleIds.length < incident.requiredVehicles && (
                      <div className="vehicle-assignment-section">
                        <div className="assignment-label">Fahrzeug zuweisen:</div>
                        <div className="vehicle-assignment-grid">
                          {availableVehicles.slice(0, 6).map(v => {
                            const config = vehicleTypeConfigs[v.vehicleType];
                            return (
                              <button
                                key={v.id}
                                onClick={() => assignVehicle(v.id, incident.id)}
                                className="assign-vehicle-button"
                                title={`${config.displayName} ${v.id} ${v.status === 'S8' ? '(Umleitung)' : ''}`}
                              >
                                <div className="assign-vehicle-icon">{config.icon}</div>
                                <div className="assign-vehicle-id">{v.id}</div>
                                {v.status === 'S8' && <div className="redirect-indicator">‚Üª</div>}
                              </button>
                            );
                          })}
                        </div>
                        {availableVehicles.length === 0 && (
                          <div className="no-vehicles-warning">‚ö†Ô∏è Keine Fahrzeuge verf√ºgbar</div>
                        )}
                      </div>
                    )}

                    {/* Verst√§rkung Button */}
                    <button
                      className="backup-button"
                      onClick={() => requestBackup(incident.id)}
                      title="Zus√§tzliches Fahrzeug anfordern"
                    >
                      + Verst√§rkung
                    </button>
                  </div>
                );
              })}
            </div>
          </div>

          {/* RIGHT COLUMN: Anrufe & Sprechwunsch (lstsim.de Style) */}
          <div className="calls-and-speaks-panel">
            {/* Sprechwunsch Section (S5) */}
            <div className="speaks-section">
              <div className="panel-header-small">
                <h4>Sprechwunsch</h4>
              </div>
              <div className="panel-content-small">
                {vehicles.filter(v => v.status === 'S5').length === 0 && (
                  <div className="empty-state-small">Keine Sprechw√ºnsche</div>
                )}
                {vehicles.filter(v => v.status === 'S5').map(vehicle => {
                  const config = vehicleTypeConfigs[vehicle.vehicleType];
                  return (
                    <div key={vehicle.id} className="speak-request-item">
                      <div className="speak-vehicle-header">
                        {config.icon} {config.displayName} {vehicle.id}
                      </div>
                      <div className="speak-message">{vehicle.speakRequest || 'M√∂chte sprechen'}</div>
                      <button
                        className="answer-speak-btn"
                        onClick={() => {
                          // Status zur√ºck zu vorherigem Status
                          setVehicles(prev => prev.map(v =>
                            v.id === vehicle.id ? { ...v, status: 'S4', speakRequest: null } : v
                          ));
                          addLog(`S-${vehicle.id.toString().padStart(2, '0')} Sprechwunsch beantwortet`, 'assignment');
                        }}
                      >
                        Best√§tigen
                      </button>
                    </div>
                  );
                })}
              </div>
            </div>

            {/* Anrufe Section */}
            <div className="calls-section">
              <div className="panel-header-small">
                <h4>Anrufe</h4>
                <button className="new-call-btn-small" onClick={() => generateCall()}>+</button>
              </div>
              <div className="panel-content-small">
                {calls.length === 0 && (
                  <div className="empty-state-small">Keine eingehenden Anrufe</div>
                )}
                {calls.map(call => {
                  const timeAgo = Math.floor((Date.now() - call.timestamp) / 1000);

                  // Wartezeit-basierte Klasse
                  let waitTimeClass = 'wait-time-normal';
                  if (timeAgo > 120) {
                    waitTimeClass = 'wait-time-critical'; // 2+ Minuten - ROT + Pulsieren
                  } else if (timeAgo > 60) {
                    waitTimeClass = 'wait-time-urgent'; // 1-2 Minuten - ORANGE
                  } else if (timeAgo > 30) {
                    waitTimeClass = 'wait-time-warning'; // 30-60s - GELB
                  }

                  // Neu eingetroffene Anrufe blinken (erste 5 Sekunden)
                  const isNew = timeAgo < 5;

                  return (
                    <div
                      key={call.id}
                      className={`call-item-lstsim ${waitTimeClass} ${isNew ? 'call-new' : ''}`}
                    >
                      <div className="call-header-lstsim">
                        <span className="call-time-lstsim">{timeAgo}s</span>
                        <span className={`call-priority-badge priority-${call.priority}`}>
                          {call.priority === 'high' ? 'DRINGEND' : call.priority === 'medium' ? 'NORMAL' : 'NIEDRIG'}
                        </span>
                      </div>
                      <div className="call-type-lstsim">{call.type}</div>
                      <div className="call-location-lstsim">{call.locationName}</div>
                      <button
                        className="accept-call-btn-lstsim"
                        onClick={() => openCallModal(call.id)}
                      >
                        Anruf annehmen
                      </button>
                    </div>
                  );
                })}
              </div>
            </div>
          </div>
        </div>
      </div>

      {/* BOTTOM BAR: Time, Weather, Speed Controls */}
      <div className="bottom-bar">
        <div className="bottom-bar-left">
          <div className="game-time-display">
            {getTimeOfDayIcon(hours)} {formattedTime} Uhr
          </div>
          <div className="score-display">
            Punkte: {score}
          </div>
        </div>
        <div className="bottom-bar-center">
          <span className="station-name">{selectedStationData?.name}</span>
        </div>
        <div className="bottom-bar-right">
          <button
            className={`speed-btn ${gameSpeed === 1 && !isPaused ? 'active' : ''}`}
            onClick={() => { setGameSpeed(1); setIsPaused(false); }}
          >
            1x
          </button>
          <button
            className={`speed-btn ${gameSpeed === 2 && !isPaused ? 'active' : ''}`}
            onClick={() => { setGameSpeed(2); setIsPaused(false); }}
          >
            2x
          </button>
          <button
            className={`speed-btn ${gameSpeed === 3 && !isPaused ? 'active' : ''}`}
            onClick={() => { setGameSpeed(3); setIsPaused(false); }}
          >
            3x
          </button>
          <button
            className={`speed-btn ${gameSpeed === 4 && !isPaused ? 'active' : ''}`}
            onClick={() => { setGameSpeed(4); setIsPaused(false); }}
          >
            4x
          </button>
          <button
            className={`speed-btn ${isPaused ? 'active paused' : ''}`}
            onClick={() => setIsPaused(!isPaused)}
          >
            {isPaused ? '‚ñ∂Ô∏è Weiter' : '‚è∏Ô∏è Pause'}
          </button>
          <button className="header-btn" onClick={() => setShowStatsModal(true)}>
            üìä Statistik
          </button>
        </div>
      </div>

      {/* Toast-Benachrichtigungen deaktiviert - Anrufe blinken stattdessen im Anruf-Bereich */}

      {showAchievementToast && (
        <div style={{
          position: 'fixed',
          top: '70px',
          left: '50%',
          transform: 'translateX(-50%)',
          background: '#30d158',
          color: 'white',
          padding: '16px 24px',
          borderRadius: '12px',
          boxShadow: '0 8px 32px rgba(0,0,0,0.2)',
          zIndex: 2000,
          fontSize: '15px',
          fontWeight: '600',
          animation: 'slideIn 0.3s ease-out',
        }}>
          {showAchievementToast.icon} {showAchievementToast.title} freigeschaltet!
        </div>
      )}

      <StatisticsModal
        isOpen={showStatsModal}
        onClose={() => setShowStatsModal(false)}
        stats={statistics}
      />

      <CallModal
        call={selectedCall}
        isOpen={isCallModalOpen}
        onClose={() => {
          setIsCallModalOpen(false);
          setSelectedCall(null);
        }}
        onAccept={acceptCall}
        onReject={rejectCall}
      />
    </div>
  );
}

export default App;
