import React, { useState, useEffect, useRef } from 'react';
import { MapContainer, TileLayer, Marker, Popup, Polyline, useMap } from 'react-leaflet';
import L from 'leaflet';
import 'leaflet/dist/leaflet.css';
import './App.css';
import { getRoute, convertToLeafletFormat, getPointAlongRoute, getStraightLineRoute, calculateDistance } from './services/routingService';
import StatisticsModal, { type Statistics } from './components/StatisticsModal';
import Toast, { type ToastData } from './components/Toast';
import ProtocolLog, { type LogEntry } from './components/ProtocolLog';
import { soundManager } from './utils/soundEffects';
import type { VehicleStatus, VehicleType, Vehicle, Call, Incident, Achievement } from './types';
import { vehicleTypeConfigs } from './constants/vehicleTypes';
import { policeStations, frankfurtLocations } from './constants/locations';
import { incidentTypes, incidentProcessingTimes, escalationRules } from './constants/incidents';
import { getWeightedIncidentType, calculateMinETA, createIncidentIcon } from './utils/gameLogic';
import { getRandomCallText, generateCallbackNumber } from './constants/callTexts';
import { getRandomPOI, getPOICategoryForIncident } from './constants/frankfurtPOIs';
import { getRealisticCallText } from './constants/realisticCallTexts';
import { getAddressForLocation } from './constants/addresses';
import { speakRequestMessages, type SpeakRequestReason } from './constants/radioMessages';
import CallModal from './components/CallModal';
import BackupModal from './components/BackupModal';
import ProtocolPanel from './components/ProtocolPanel';
import { protocolLogger } from './utils/protocolLogger';
import type { ProtocolEntry } from './types/protocol';
import WeatherDisplay from './components/WeatherDisplay';
import type { WeatherState } from './types/weather';
import { weatherConditions, getWeatherDuration, getNextWeather, getWeatherOverlayClass } from './constants/weather';
import { calculateFuelConsumption, calculateCrewFatigue, determineOutOfServiceReason, calculateOutOfServiceDuration, updateMaintenanceStatus, resetVehicleAfterService } from './utils/vehicleTimings';
import { shouldTriggerMANV, getRandomMANVScenario, generateInvolvedCount } from './constants/manvScenarios';
import RadioLog, { type RadioMessage } from './components/RadioLog';
import { generateRadioMessage } from './constants/radioMessages';
import { gasStations } from './constants/gasStations';
import { findBestVehicles, getAutoAssignmentRecommendations } from './utils/smartAssignment';
import { findNearestGasStation, shouldRefuel, calculateRefuelDuration, shouldTakeBreak, performShiftChange } from './utils/refuelingSystem';
import { canHelicopterFly, getProcessingTimeMultiplier, getWeatherWarning } from './constants/weather';
import { useHotkeys } from './hooks/useHotkeys';
import { LogFilters } from './components/LogFilters';
import type { GasStation } from './types';

// Fix Leaflet default marker icon issue
delete (L.Icon.Default.prototype as any)._getIconUrl;
L.Icon.Default.mergeOptions({
  iconRetinaUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-icon-2x.png',
  iconUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-icon.png',
  shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-shadow.png',
});

// Types, constants, and helpers are imported from centralized modules
// See: src/types, src/constants, src/utils for definitions

// Local interfaces that are specific to this component
interface VehicleMarkerProps {
  position: [number, number];
  bearing: number;
  status: VehicleStatus;
  vehicle: Vehicle;
}

type Difficulty = 'Leicht' | 'Mittel' | 'Schwer';

// Modern police station marker - Hessischer Polizeistern
const createStationIcon = () => {
  return L.divIcon({
    className: 'station-marker',
    html: `
      <div class="station-marker-container">
        <div style="width: 48px; height: 48px; background: rgba(48, 209, 88, 0.15); border-radius: 50%; display: flex; align-items: center; justify-content: center;">
          <img src="/polizeistern-hessen.svg" alt="Polizeiwache" width="36" height="36" style="filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2));" />
        </div>
      </div>
    `,
    iconSize: [48, 48],
    iconAnchor: [24, 24],
  });
};

// Gas Station Icon
const createGasStationIcon = () => {
  return L.divIcon({
    className: 'gas-station-marker',
    html: `
      <div class="gas-station-marker-container">
        <div style="width: 36px; height: 36px; background: #4CAF50; border-radius: 50%; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">
          <span style="font-size: 20px;">‚õΩ</span>
        </div>
      </div>
    `,
    iconSize: [36, 36],
    iconAnchor: [18, 18],
  });
};

// Map center updater component
const MapCenterUpdater: React.FC<{ center: [number, number]; zoom?: number }> = ({ center, zoom = 16 }) => {
  const map = useMap();
  useEffect(() => {
    map.setView(center, zoom, { animate: true, duration: 0.5 });
  }, [center, zoom, map]);
  return null;
};

// VehicleMarker component with independent Blaulicht animation
const VehicleMarker: React.FC<VehicleMarkerProps> = ({ position, status, vehicle }) => {
  const [blaulichtOn, setBlaulichtOn] = useState(false);

  // ECE-R65 / DIN 14620 compliant Blaulicht pattern - only for this vehicle
  useEffect(() => {
    // Only animate if vehicle is on mission (S3 or S4)
    if (status !== 'S3' && status !== 'S4') {
      setBlaulichtOn(false);
      return;
    }

    let step = 0;
    const pattern = [
      { duration: 80, state: true },   // First flash
      { duration: 80, state: false },  // Short pause between flashes
      { duration: 80, state: true },   // Second flash (Doppelblitz)
      { duration: 260, state: false }, // Pause until next group (~500ms total)
    ];

    const runPattern = () => {
      setBlaulichtOn(pattern[step].state);
      setTimeout(() => {
        step = (step + 1) % pattern.length;
        runPattern();
      }, pattern[step].duration);
    };

    runPattern();
  }, [status]);

  // Determine which CSS class to use based on status and blaulicht state
  const isBlaulichtActive = (status === 'S3' || status === 'S4') && blaulichtOn;
  const vehicleClass = isBlaulichtActive ? 'vehicle-icon-blaulicht-on' : 'vehicle-icon-blaulicht-off';

  const icon = L.divIcon({
    className: 'vehicle-marker',
    html: `
      <div class="vehicle-marker-container">
        <div class="${vehicleClass}"></div>
      </div>
    `,
    iconSize: [64, 64],
    iconAnchor: [32, 32],
  });

  const statusLabels: { [key in VehicleStatus]: string } = {
    S1: 'Bereit',
    S3: 'Anfahrt',
    S4: 'Am Einsatzort',
    S5: 'Sprechwunsch',
    S6: 'Au√üer Dienst',
    S8: 'R√ºckfahrt'
  };

  return (
    <Marker position={position} icon={icon}>
      <Popup>
        <strong>Fahrzeug S-{vehicle.id.toString().padStart(2, '0')}</strong><br />
        Status: {statusLabels[status]}
      </Popup>
    </Marker>
  );
};

// Achievement definitions
const achievementDefinitions = [
  {
    id: 'first_response',
    title: 'Erster Einsatz',
    description: 'Schlie√üe deinen ersten Einsatz erfolgreich ab',
    icon: 'üéñÔ∏è',
    condition: (stats: Statistics) => stats.totalResolved >= 1,
  },
  {
    id: 'century',
    title: 'Jahrhundert',
    description: 'Schlie√üe 100 Eins√§tze erfolgreich ab',
    icon: 'üèÜ',
    condition: (stats: Statistics) => stats.totalResolved >= 100,
  },
  {
    id: 'streak_10',
    title: 'Im Flow',
    description: 'Erreiche eine Serie von 10 erfolgreichen Eins√§tzen',
    icon: 'üî•',
    condition: (stats: Statistics) => stats.currentStreak >= 10,
  },
  {
    id: 'speed_demon',
    title: 'Blitzschnell',
    description: 'Durchschnittliche Reaktionszeit unter 60 Sekunden',
    icon: '‚ö°',
    condition: (stats: Statistics) => {
      if (stats.totalResponseTimes.length === 0) return false;
      const avg = stats.totalResponseTimes.reduce((a, b) => a + b, 0) / stats.totalResponseTimes.length;
      return avg < 60;
    },
  },
  {
    id: 'perfect_shift',
    title: 'Perfekte Schicht',
    description: 'Keine fehlgeschlagenen Eins√§tze in einer Schicht mit 20+ Eins√§tzen',
    icon: 'üíé',
    condition: (stats: Statistics) => stats.totalResolved >= 20 && stats.totalFailed === 0,
  },
];

// LocalStorage keys
const STORAGE_KEYS = {
  ACHIEVEMENTS: 'polizei_achievements',
  STATS: 'polizei_stats',
  HIGH_SCORE: 'polizei_high_score',
};

function App() {
  const [gameStarted, setGameStarted] = useState(false);
  const [selectedStation, setSelectedStation] = useState<number | null>(null);
  const [vehicles, setVehicles] = useState<Vehicle[]>([]);
  const [incidents, setIncidents] = useState<Incident[]>([]);
  const [calls, setCalls] = useState<Call[]>([]); // NEW: Calls system
  const [callIdCounter, setCallIdCounter] = useState(1); // NEW: Call ID counter
  const [selectedCall, setSelectedCall] = useState<Call | null>(null); // NEU: Ausgew√§hlter Anruf f√ºr Modal
  const [isCallModalOpen, setIsCallModalOpen] = useState(false); // NEU: Call Modal State
  const [selectedIncidentForBackup, setSelectedIncidentForBackup] = useState<Incident | null>(null); // Verst√§rkung Modal
  const [isBackupModalOpen, setIsBackupModalOpen] = useState(false); // Backup Modal State
  const [score, setScore] = useState(0);
  const [incidentCounter, setIncidentCounter] = useState(1);
  const [mapCenter, setMapCenter] = useState<[number, number]>([50.1109, 8.6821]);
  const [mapZoom, setMapZoom] = useState<number>(13);
  const [isTimeDropdownOpen, setIsTimeDropdownOpen] = useState(false);

  // State for features
  const [selectedTime, setSelectedTime] = useState<number>(8);
  const [gameTime, setGameTime] = useState<number>(8 * 60);
  const [difficulty, setDifficulty] = useState<Difficulty>('Mittel');
  const [gameSpeed, setGameSpeed] = useState<1 | 2 | 3 | 4>(1); // Spielgeschwindigkeit
  const [isPaused, setIsPaused] = useState(false); // Pause-Status
  const [statistics, setStatistics] = useState<Statistics>({
    totalResolved: 0,
    totalFailed: 0,
    totalResponseTimes: [],
    incidentsByType: {},
    currentStreak: 0,
    bestStreak: 0,
    totalDistance: 0,
  });
  const [showStatsModal, setShowStatsModal] = useState(false);
  const [_toasts, setToasts] = useState<ToastData[]>([]);
  const [toastCounter, setToastCounter] = useState(1);
  const [_logs, setLogs] = useState<LogEntry[]>([]);
  const [logCounter, setLogCounter] = useState(1);
  const [achievements, setAchievements] = useState<Achievement[]>([]);
  const [showAchievementToast, setShowAchievementToast] = useState<Achievement | null>(null);
  const [selectedVehicleId, setSelectedVehicleId] = useState<number | null>(null);
  const [expandedIncidents, setExpandedIncidents] = useState<Set<number>>(new Set()); // Aufgeklappte Eins√§tze
  const [vehicleFilter, setVehicleFilter] = useState<VehicleStatus | 'all'>('all'); // Filter f√ºr Fahrzeugliste

  // RadioLog System
  const [radioMessages, setRadioMessages] = useState<RadioMessage[]>([]);
  const radioMessageIdRef = useRef(1);

  // Log Filter System
  const [filteredLogs, setFilteredLogs] = useState<LogEntry[]>([]);

  // Weather System
  const [weather, setWeather] = useState<WeatherState>({
    current: 'sunny',
    duration: 120,
    nextChange: 8 * 60 + 120,
    forecast: 'rainy',
  });
  // Protocol System
  const [showProtocolPanel, setShowProtocolPanel] = useState(false);
  const [protocolEntries, setProtocolEntries] = useState<ProtocolEntry[]>([]);
  // Load saved data on mount (mit Error Handling f√ºr LocalStorage)
  useEffect(() => {
    try {
      const savedAchievements = localStorage.getItem(STORAGE_KEYS.ACHIEVEMENTS);
      if (savedAchievements) {
        setAchievements(JSON.parse(savedAchievements));
      } else {
        setAchievements(achievementDefinitions.map(a => ({ ...a, unlocked: false })));
      }

      const savedStats = localStorage.getItem(STORAGE_KEYS.STATS);
      if (savedStats) {
        setStatistics(JSON.parse(savedStats));
      }
    } catch (error) {
      console.error('Fehler beim Laden der gespeicherten Daten:', error);
      // Fallback: Neue Achievements initialisieren
      setAchievements(achievementDefinitions.map(a => ({ ...a, unlocked: false })));
    }
  }, []);

  // Save data whenever it changes (mit Error Handling f√ºr LocalStorage)
  useEffect(() => {
    if (gameStarted) {
      try {
        localStorage.setItem(STORAGE_KEYS.STATS, JSON.stringify(statistics));
        localStorage.setItem(STORAGE_KEYS.ACHIEVEMENTS, JSON.stringify(achievements));
        if (score > 0) {
          const highScore = localStorage.getItem(STORAGE_KEYS.HIGH_SCORE);
          if (!highScore || score > parseInt(highScore)) {
            localStorage.setItem(STORAGE_KEYS.HIGH_SCORE, score.toString());
          }
        }
      } catch (error) {
        console.error('Fehler beim Speichern der Daten:', error);
      }
    }
  }, [statistics, achievements, score, gameStarted]);

  // Check for new achievements
  useEffect(() => {
    achievements.forEach((achievement, index) => {
      if (!achievement.unlocked) {
        const def = achievementDefinitions.find(a => a.id === achievement.id);
        if (def && def.condition(statistics)) {
          const newAchievements = [...achievements];
          newAchievements[index] = { ...achievement, unlocked: true };
          setAchievements(newAchievements);
          setShowAchievementToast(newAchievements[index]);
          soundManager.playSuccessChime();
          setTimeout(() => setShowAchievementToast(null), 5000);
        }
      }
    });
  }, [statistics, achievements]);

  // Close dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      const target = event.target as HTMLElement;
      if (isTimeDropdownOpen && !target.closest('.custom-dropdown')) {
        setIsTimeDropdownOpen(false);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, [isTimeDropdownOpen]);

  // Keyboard Shortcuts (LST-SIM Style)
  useEffect(() => {
    if (!gameStarted) return;

    const handleKeyDown = (event: KeyboardEvent) => {
      // Ignoriere Tastatureingaben in Input-Feldern
      const target = event.target as HTMLElement;
      if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA') return;

      switch (event.key.toLowerCase()) {
        case 'l':
          setShowProtocolPanel(prev => !prev);
          break;
        case 'p':
        case 'pause':
          setIsPaused(prev => !prev);
          break;
        case 'y':
          setGameSpeed(1);
          setIsPaused(false);
          break;
        case 'x':
          setGameSpeed(4);
          setIsPaused(false);
          break;
        case 'escape':
          if (showProtocolPanel) setShowProtocolPanel(false);
          if (showStatsModal) setShowStatsModal(false);
          if (isCallModalOpen) setIsCallModalOpen(false);
          break;
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [gameStarted, showProtocolPanel, showStatsModal, isCallModalOpen]);

  // Helper function to add log entry (nun mit protocolLogger)
  const addLog = (
    message: string,
    type: LogEntry['type'],
    options?: {
      vehicleId?: number;
      incidentId?: number;
      priority?: 'low' | 'medium' | 'high';
      location?: string;
      statusFrom?: VehicleStatus;
      statusTo?: VehicleStatus;
    }
  ) => {
    // Alte Logs behalten (f√ºr Kompatibilit√§t)
    const hours = Math.floor(gameTime / 60);
    const minutes = Math.floor(gameTime % 60);
    const timestamp = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;

    setLogs((prev) => {
      const newLogs = [
        ...prev,
        {
          id: logCounter,
          timestamp,
          message,
          type,
        },
      ];
      return newLogs.slice(-50);
    });
    setLogCounter((prev) => prev + 1);

    // Neues Protocol-System
    const mapTypeToProtocol = (logType: LogEntry['type']) => {
      const mapping: { [key in LogEntry['type']]: 'call' | 'assignment' | 'status' | 'radio' | 'completion' | 'failed' | 'system' } = {
        new: 'call',
        assignment: 'assignment',
        arrival: 'status',
        completion: 'completion',
        failed: 'failed',
      };
      return mapping[logType] || 'system';
    };

    const vehicleCallsign = options?.vehicleId
      ? `${vehicleTypeConfigs[vehicles.find(v => v.id === options.vehicleId)?.vehicleType || 'Streifenwagen'].displayName} ${options.vehicleId.toString().padStart(2, '0')}`
      : undefined;

    protocolLogger.addEntry(
      mapTypeToProtocol(type),
      message,
      gameTime,
      {
        ...options,
        vehicleCallsign,
      }
    );

    setProtocolEntries(protocolLogger.getEntries());
  };

  // ‚ö° Helper function to add radio message (LST-SIM Style)
  const addRadioMessage = (
    vehicleId: number,
    statusFrom: VehicleStatus,
    statusTo: VehicleStatus,
    options?: {
      incidentType?: string;
      location?: string;
      requiresResponse?: boolean;
      customMessage?: string;
    }
  ) => {
    const vehicle = vehicles.find(v => v.id === vehicleId);
    if (!vehicle) return;

    const hours = Math.floor(gameTime / 60);
    const minutes = Math.floor(gameTime % 60);
    const timestamp = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;

    const config = vehicleTypeConfigs[vehicle.vehicleType];
    const vehicleCallsign = `${config.displayName} ${vehicleId.toString().padStart(2, '0')}`;

    const message = options?.customMessage || generateRadioMessage(
      vehicleCallsign,
      statusFrom,
      statusTo,
      options?.incidentType,
      options?.location
    );

    // Verwende Ref f√ºr atomare ID-Generierung (verhindert doppelte IDs im Strict Mode)
    const messageId = radioMessageIdRef.current++;
    const newMessage: RadioMessage = {
      id: messageId,
      timestamp,
      vehicleCallsign,
      message,
      type: 'incoming',
      requiresResponse: options?.requiresResponse || false,
      vehicleId,
    };

    // Deduplizierung: Pr√ºfe ob exakt dieselbe Nachricht bereits existiert
    setRadioMessages(prev => {
      const isDuplicate = prev.some(m =>
        m.vehicleId === vehicleId &&
        m.message === message &&
        m.timestamp === timestamp &&
        m.type === 'incoming'
      );

      if (isDuplicate) {
        return prev; // Ignoriere Duplikat
      }

      return [...prev, newMessage].slice(-50);
    });
  };

  // ‚ö° HOTKEY-SYSTEM Integration
  useHotkeys({
    onEndMission: () => {
      if (selectedVehicleId) {
        const vehicle = vehicles.find(v => v.id === selectedVehicleId);
        if (vehicle && vehicle.status === 'S4') {
          // Einsatz sofort beenden
          setVehicles(prev => prev.map(v =>
            v.id === selectedVehicleId ? { ...v, processingStartTime: Date.now() - vehicle.processingDuration * 1000 } : v
          ));
          addLog(`üéÆ HOTKEY: Fahrzeug ${selectedVehicleId} - Einsatz beendet`, 'system');
        }
      }
    },
    onReturnToStation: () => {
      if (selectedVehicleId) {
        const vehicle = vehicles.find(v => v.id === selectedVehicleId);
        if (vehicle && (vehicle.status === 'S4' || vehicle.status === 'S5')) {
          returnToStation(selectedVehicleId);
          addLog(`üéÆ HOTKEY: Fahrzeug ${selectedVehicleId} zur√ºck zur Wache`, 'system');
        }
      }
    },
    onTogglePause: () => {
      setIsPaused(prev => !prev);
    },
    onIncreaseSpeed: () => {
      setGameSpeed(prev => Math.min(4, prev + 1) as 1 | 2 | 3 | 4);
    },
    onDecreaseSpeed: () => {
      setGameSpeed(prev => Math.max(1, prev - 1) as 1 | 2 | 3 | 4);
    },
    onSelectVehicle: (vehicleId) => {
      if (vehicles.find(v => v.id === vehicleId)) {
        setSelectedVehicleId(vehicleId);
        const vehicle = vehicles.find(v => v.id === vehicleId);
        if (vehicle) {
          setMapCenter(vehicle.position);
          setMapZoom(16);
        }
      }
    },
    onClearSelection: () => {
      setSelectedVehicleId(null);
    },
  }, gameStarted);

  // Get difficulty settings (lstsim.de style - realistic balance)
  const getDifficultySettings = () => {
    switch (difficulty) {
      case 'Leicht':
        return {
          vehicleCount: 6,
          vehicleTypes: ['Streifenwagen', 'Streifenwagen', 'Streifenwagen', 'Streifenwagen', 'SEK', 'Zivilfahrzeug'] as VehicleType[],
          incidentsPerHour: 1.5,  // 1.5 Eins√§tze pro Stunde
          maxIncidents: 2,
          baseTimeLimit: 90,
        };
      case 'Schwer':
        return {
          vehicleCount: 4,
          vehicleTypes: ['Streifenwagen', 'Streifenwagen', 'SEK', 'Polizeihubschrauber'] as VehicleType[],
          incidentsPerHour: 3.5,  // 3.5 Eins√§tze pro Stunde
          maxIncidents: 4,
          baseTimeLimit: 45,
        };
      default: // Mittel
        return {
          vehicleCount: 5,
          vehicleTypes: ['Streifenwagen', 'Streifenwagen', 'Streifenwagen', 'SEK', 'Zivilfahrzeug'] as VehicleType[],
          incidentsPerHour: 2.5,  // 2.5 Eins√§tze pro Stunde (lstsim.de Standard)
          maxIncidents: 3,
          baseTimeLimit: 60,
        };
    }
  };

  // Initialize vehicles for selected station
  const startGame = (stationId: number) => {
    const station = policeStations.find(s => s.id === stationId);
    if (!station) return;

    setSelectedStation(stationId);
    setMapCenter(station.position);
    setGameTime(selectedTime * 60);

    const settings = getDifficultySettings();
    const newVehicles: Vehicle[] = [];

    for (let i = 0; i < settings.vehicleCount; i++) {
      const vehicleType = settings.vehicleTypes[i] || 'Streifenwagen';
      newVehicles.push({
        id: i + 1,
        stationId,
        position: station.position,
        assignedIncidentId: null,
        routeIndex: 0,
        route: null,
        routeProgress: 0,
        bearing: 0,
        routeDuration: 0,
        routeStartTime: 0,
        totalDistanceTraveled: 0,
        isAvailable: true,
        status: 'S1', // Bereit an Wache
        processingStartTime: null,
        processingDuration: 0,
        // NEU: Fahrzeugtyp-spezifische Eigenschaften
        vehicleType: vehicleType,
        speakRequest: null,
        outOfServiceReason: null,
        outOfServiceUntil: null,
        canBeRedirected: true, // lstsim.de: S8-Fahrzeuge k√∂nnen umgeleitet werden
        situationReportSent: false,
        // Realistische Timings
        fuelLevel: 100,
        crewFatigue: 0,
        maintenanceStatus: 'ok' as const,
        lastRefuelTime: 0,
        lastBreakTime: 0,
        shiftStartTime: gameTime,
        accumulatedTime: 0,
      });
    }

    setVehicles(newVehicles);
    setGameStarted(true);

    addLog(`Schicht begonnen in ${station.name}`, 'new');
    setTimeout(() => generateIncident(), 2000);
  };

  // NEW: Generate random call (instead of incident directly) - LST SIM Style mit Gespr√§chstext
  // ERWEITERT: Nutzt POI-System f√ºr realistische Orte und Kontexte
  // MAXIMALE VARIATION: Jeden Spieldurchlauf anders gestalten
  const generateCall = () => {
    const hour = Math.floor(gameTime / 60);

    // üé≤ ERH√ñHTE ZUF√ÑLLIGKEIT: Manchmal ignoriere Tageszeit-Gewichtung
    const ignoreTimeWeighting = Math.random() < 0.3; // 30% komplett zuf√§llig

    // ‚ö° MANV-CHECK: Soll eine Gro√ülage generiert werden?
    const triggerMANV = shouldTriggerMANV(difficulty);

    let incidentType;
    let isMANV = false;
    let manvScenario = null;
    let involvedCount = 0;

    if (triggerMANV) {
      // üö® GROSSLAGE generieren!
      manvScenario = getRandomMANVScenario();
      involvedCount = generateInvolvedCount(manvScenario);
      incidentType = {
        type: manvScenario.type,
        description: manvScenario.description,
        priority: manvScenario.priority,
        requiredVehicles: manvScenario.requiredVehicles
      };
      isMANV = true;

    } else if (ignoreTimeWeighting) {
      // Komplett zuf√§lliger Einsatztyp (ohne Tageszeit-Gewichtung)
      incidentType = incidentTypes[Math.floor(Math.random() * incidentTypes.length)];

    } else {
      // Tageszeit-gewichteter Einsatz
      incidentType = getWeightedIncidentType(hour);

    }

    // üé≤ ERH√ñHTE VARIATION: POI-Nutzung variieren (50-90% statt fix 70%)
    const preferredCategory = getPOICategoryForIncident(incidentType.type);
    const poiChance = 0.5 + Math.random() * 0.4; // 50-90% POI-Chance
    const usePOI = preferredCategory && Math.random() < poiChance;

    let location;
    let callerText;
    let callerType: 'witness' | 'victim' | 'resident' | 'business' | 'anonymous' | 'employee';
    let callerName: string | undefined;

    if (usePOI && preferredCategory) {
      // üé≤ Manchmal nutze auch andere POI-Kategorien f√ºr √úberraschungen
      const useRandomCategory = Math.random() < 0.15; // 15% komplett zuf√§llige Kategorie
      const poi = useRandomCategory ? getRandomPOI() : getRandomPOI(preferredCategory);
      location = { name: poi.name, position: poi.position };



      // Hole POI-spezifischen, extrem realistischen Anrufertext
      const realisticCall = getRealisticCallText(incidentType.type, poi.category, poi.name);

      if (realisticCall) {
        callerText = realisticCall.text;
        callerType = realisticCall.callerType;
        callerName = realisticCall.callerName;
      } else {
        // Fallback zu Standard-Texten
        const fallback = getRandomCallText(incidentType.type);
        callerText = fallback.text;
        callerType = fallback.callerType;
        callerName = fallback.callerName;
      }
    } else {
      // Nutze normale Frankfurt-Locations
      location = frankfurtLocations[Math.floor(Math.random() * frankfurtLocations.length)];
      const callTextData = getRandomCallText(incidentType.type);
      callerText = callTextData.text;
      callerType = callTextData.callerType;
      callerName = callTextData.callerName;
    }

    const hasCallbackNumber = Math.random() < 0.7; // 70% haben R√ºckrufnummer

    // Bestimme ob es eine Privatadresse ist (residential POI oder kein POI)
    const isPrivateAddress = !usePOI || (preferredCategory === 'residential');
    const address = getAddressForLocation(location.name, isPrivateAddress);

    const newCall = {
      id: callIdCounter,
      type: incidentType.type,
      position: location.position as [number, number],
      priority: incidentType.priority as 'low' | 'medium' | 'high',
      description: incidentType.description,
      locationName: location.name,
      timestamp: Date.now(),
      answered: false,
      // NEU: LST SIM Style Eigenschaften
      callerText: isMANV
        ? `GROSSLAGE! ${manvScenario!.type} mit ca. ${involvedCount} Beteiligten! Sofort mehrere Einheiten entsenden!`
        : callerText,
      callerType: isMANV ? 'witness' : callerType,
      callerName,
      callbackNumber: hasCallbackNumber ? generateCallbackNumber() : undefined,
      address, // Echte Adresse
      status: 'waiting' as const,
      // ‚ö° MANV-Daten
      isMANV,
      involvedCount: isMANV ? involvedCount : undefined,
    };

    setCalls(prev => [...prev, newCall]);
    setCallIdCounter(prev => prev + 1);

    setToasts((prev) => [
      ...prev,
      {
        id: toastCounter,
        type: `Anruf: ${incidentType.type}`,
        location: location.name,
        priority: incidentType.priority as 'low' | 'medium' | 'high',
        incidentId: callIdCounter,
      },
    ]);
    setToastCounter((prev) => prev + 1);

    if (incidentType.priority === 'high') {
      soundManager.playAlertSound();
    }

    addLog(`Notruf eingehend: ${incidentType.type} in ${location.name}`, 'new');
  };

  // NEU: √ñffne Call-Modal zum Anrufer-Gespr√§ch
  const openCallModal = (callId: number) => {
    const call = calls.find(c => c.id === callId);
    if (!call) return;

    setSelectedCall(call);
    setIsCallModalOpen(true);
    soundManager.playSirenBeep();
  };

  // NEU: Lehne Anruf ab (Auflegen)
  const rejectCall = (callId: number) => {
    setCalls(prev => prev.map(c =>
      c.id === callId ? { ...c, status: 'rejected' as const, answered: true } : c
    ));
    addLog(`Anruf abgelehnt: ${calls.find(c => c.id === callId)?.type || 'Unbekannt'}`, 'failed');

    // Entferne abgelehnte Anrufe nach 3 Sekunden
    setTimeout(() => {
      setCalls(prev => prev.filter(c => c.id !== callId));
    }, 3000);
  };

  // NEW: Accept call and create incident (nur noch aus Modal heraus aufrufbar)
  // Mit optionaler direkter Fahrzeugzuweisung aus dem Modal
  const acceptCall = (callId: number, preAssignedVehicles?: number[]) => {
    const call = calls.find(c => c.id === callId);
    if (!call) return;

    const settings = getDifficultySettings();
    const incidentType = incidentTypes.find(it => it.type === call.type);
    if (!incidentType) return;

    // Eskalationslogik: 10% Chance, kann eskalieren
    const canEscalate = escalationRules[call.type] !== undefined && Math.random() < 0.1;
    const escalationDelay = canEscalate ? 60 + Math.random() * 30 : 0; // 60-90 Sekunden

    const newIncidentId = incidentCounter; // Speichere ID f√ºr sp√§tere Verwendung
    const newIncident = {
      id: newIncidentId,
      type: call.type,
      position: call.position,
      assignedVehicleIds: preAssignedVehicles || [], // Verwende vorausgew√§hlte Fahrzeuge
      priority: call.priority,
      description: `${call.description} - ${call.locationName}`,
      timeRemaining: settings.baseTimeLimit,
      locationName: call.locationName,
      spawnTime: Date.now(),
      requiredVehicles: incidentType.requiredVehicles,
      arrivedVehicles: 0,
      processingDuration: incidentProcessingTimes[call.type] || 180,
      canEscalate: canEscalate,
      escalationTime: canEscalate ? Date.now() + escalationDelay * 1000 : null,
      hasEscalated: false,
      isMANV: false,
    };

    setIncidents(prev => [...prev, newIncident]);
    setIncidentCounter(prev => prev + 1);

    // Wenn Fahrzeuge bereits zugewiesen wurden, setze sie SOFORT auf S3 (INLINE)
    if (preAssignedVehicles && preAssignedVehicles.length > 0) {


      // INLINE State-Update mit prevVehicles Callback - keine Closure-Probleme!
      setVehicles(prevVehicles => {
        return prevVehicles.map(v => {
          if (!preAssignedVehicles.includes(v.id)) return v;
          if (v.status !== 'S1' && !(v.status === 'S8' && v.canBeRedirected)) return v;

          // Setze auf S2 (Alarmierung) - noch nicht sichtbar
          const updatedVehicle = {
            ...v,
            assignedIncidentId: newIncidentId,
            status: 'S2' as VehicleStatus,
            routeStartTime: Date.now(),
            routeProgress: 0,
            route: null,  // Wird async berechnet
            accumulatedTime: 0,
          };

          // Route async berechnen, dann zu S3 wechseln
          (async () => {
            try {
              const route = await getRoute(
                { lat: v.position[0], lng: v.position[1] },
                { lat: newIncident.position[0], lng: newIncident.position[1] }
              );

              // Wechsle zu S3 wenn Route fertig
              if (route) {
                setVehicles(prev => prev.map(vehicle =>
                  vehicle.id === v.id ? {
                    ...vehicle,
                    status: 'S3' as VehicleStatus,
                    route: convertToLeafletFormat(route.coordinates),
                    routeDuration: route.duration * 0.7
                  } : vehicle
                ));
              } else {
                // Fallback: Straight Line Route
                const straightRoute = getStraightLineRoute(
                  { lat: v.position[0], lng: v.position[1] },
                  { lat: newIncident.position[0], lng: newIncident.position[1] }
                );
                const straightDistance = calculateDistance(
                  { lat: v.position[0], lng: v.position[1] },
                  { lat: newIncident.position[0], lng: newIncident.position[1] }
                );
                setVehicles(prev => prev.map(vehicle =>
                  vehicle.id === v.id ? {
                    ...vehicle,
                    status: 'S3' as VehicleStatus,
                    route: straightRoute,
                    routeDuration: Math.max(60, straightDistance / 20)
                  } : vehicle
                ));
              }
            } catch {
              // Fehlerfall: Straight Line Route
              const straightRoute = getStraightLineRoute(
                { lat: v.position[0], lng: v.position[1] },
                { lat: newIncident.position[0], lng: newIncident.position[1] }
              );
              const straightDistance = calculateDistance(
                { lat: v.position[0], lng: v.position[1] },
                { lat: newIncident.position[0], lng: newIncident.position[1] }
              );
              setVehicles(prev => prev.map(vehicle =>
                vehicle.id === v.id ? {
                  ...vehicle,
                  status: 'S3' as VehicleStatus,
                  route: straightRoute,
                  routeDuration: Math.max(60, straightDistance / 20)
                } : vehicle
              ));
            }
          })();

          addLog(`S-${v.id.toString().padStart(2, '0')} S1‚ÜíS2 Einsatz #${newIncidentId}`, 'assignment');

          // ‚ö° FUNKSPRUCH: S1 ‚Üí S2 (Alarmierung)
          addRadioMessage(v.id, 'S1', 'S2', {
            incidentType: newIncident.type,
            location: newIncident.locationName,
          });

          soundManager.playSirenBeep();

          return updatedVehicle;
        });
      });
    }

    // Markiere Call als "answered" und entferne nach kurzer Verz√∂gerung
    setCalls(prev => prev.map(c =>
      c.id === callId ? { ...c, status: 'answered' as const, answered: true } : c
    ));

    // Entferne angenommene Anrufe nach 2 Sekunden
    setTimeout(() => {
      setCalls(prev => prev.filter(c => c.id !== callId));
    }, 2000);

    soundManager.playSirenBeep();
    const vehicleInfo = preAssignedVehicles && preAssignedVehicles.length > 0
      ? ` + ${preAssignedVehicles.length} Fahrzeuge zugewiesen`
      : '';
    addLog(`Anruf entgegengenommen: ${call.type} in ${call.locationName} ‚Üí Einsatz #${newIncidentId}${vehicleInfo}`, 'assignment');
  };

  // BUGFIX: generateIncident jetzt direkt als generateCall (lstsim.de Style)
  const generateIncident = () => {
    generateCall(); // Nutze Call-System wie lstsim.de
  };

  // Request backup - √∂ffnet Modal zur Fahrzeugauswahl
  const requestBackup = (incidentId: number) => {
    const incident = incidents.find(i => i.id === incidentId);
    if (!incident) return;

    setSelectedIncidentForBackup(incident);
    setIsBackupModalOpen(true);
    soundManager.playSirenBeep();
  };

  // Confirm backup - weist ausgew√§hlte Fahrzeuge zu
  const confirmBackup = (vehicleIds: number[]) => {
    if (!selectedIncidentForBackup || vehicleIds.length === 0) return;

    const incidentId = selectedIncidentForBackup.id;

    addLog(`Verst√§rkung: ${vehicleIds.length} Fahrzeug(e) zu ${selectedIncidentForBackup.type}`, 'assignment');
    soundManager.playSirenBeep();

    // Erh√∂he required vehicles
    setIncidents(prev =>
      prev.map(i =>
        i.id === incidentId
          ? {
              ...i,
              requiredVehicles: i.requiredVehicles + vehicleIds.length,
              timeRemaining: i.timeRemaining + (vehicleIds.length * 20),
            }
          : i
      )
    );

    // Weise alle ausgew√§hlten Fahrzeuge zu
    vehicleIds.forEach(vehicleId => {
      assignVehicle(vehicleId, incidentId);
    });
  };

  // Return vehicle to station (f√ºr Hotkey H)
  const returnToStation = async (vehicleId: number) => {
    const vehicle = vehicles.find(v => v.id === vehicleId);
    if (!vehicle) return;

    const station = policeStations.find(s => s.id === vehicle.stationId);
    if (!station) return;

    // Berechne Route zur Wache
    try {
      const osrmRoute = await getRoute(
        { lat: vehicle.position[0], lng: vehicle.position[1] },
        { lat: station.position[0], lng: station.position[1] }
      );

      let route: [number, number][] | null = null;
      let routeDuration = 120;

      if (osrmRoute) {
        route = convertToLeafletFormat(osrmRoute.coordinates);
        const weatherSpeedFactor = weatherConditions[weather.current].vehicleSpeedMultiplier;
        const fatigueSpeedFactor = vehicle.crewFatigue > 80 ? 0.7 : 1.0;
        routeDuration = (osrmRoute.duration * 0.7) / (weatherSpeedFactor * fatigueSpeedFactor);
      } else {
        const straightRoute = getStraightLineRoute(
          { lat: vehicle.position[0], lng: vehicle.position[1] },
          { lat: station.position[0], lng: station.position[1] }
        );
        route = convertToLeafletFormat(straightRoute);
      }

      setVehicles(prev => prev.map(v =>
        v.id === vehicleId ? {
          ...v,
          status: 'S8' as VehicleStatus,
          route,
          routeDuration,
          routeStartTime: Date.now(),
          routeProgress: 0,
          accumulatedTime: 0,
          processingStartTime: null,
          speakRequest: null,
        } : v
      ));

      addRadioMessage(vehicleId, 'S4', 'S8', {
        location: station.name,
      });
    } catch (error) {
      console.error('Fehler bei returnToStation:', error);
    }
  };

  // Neue Hilfsfunktion: Weise Fahrzeug direkt zu einem Incident-Objekt zu (verhindert Closure-Probleme)

  // Assign vehicle to incident (mit Error Handling f√ºr OSRM + lstsim.de S8-Umleitung)
  const assignVehicle = async (vehicleId: number, incidentId: number) => {


    const vehicle = vehicles.find(v => v.id === vehicleId);
    const incident = incidents.find(i => i.id === incidentId);




    // BUGFIX lstsim.de: S8-Fahrzeuge K√ñNNEN umgeleitet werden! (nur S1 + S8 erlaubt)
    const canAssign = vehicle && (vehicle.status === 'S1' || (vehicle.status === 'S8' && vehicle.canBeRedirected));

    if (!vehicle || !incident || !canAssign || incident.assignedVehicleIds.includes(vehicleId)) {

      return;
    }

    // ‚ö° WETTER-CHECK: Helicopter kann bei schlechtem Wetter nicht fliegen
    if (vehicle.vehicleType === 'Polizeihubschrauber' && !canHelicopterFly(weather.current)) {
      const weatherName = weatherConditions[weather.current].name;
      addLog(`‚ö†Ô∏è Hubschrauber ${vehicleId} kann bei ${weatherName} nicht fliegen!`, 'system');
      setToasts((prev) => [
        ...prev,
        {
          id: toastCounter,
          type: 'Helicopter grounded',
          location: `Bei ${weatherName} kann der Polizeihubschrauber nicht fliegen`,
        },
      ]);
      setToastCounter((c) => c + 1);
      return; // Verhindere Zuweisung
    }



    // Wenn Fahrzeug in S8 ist, von altem Einsatz entfernen
    if (vehicle.status === 'S8' && vehicle.assignedIncidentId) {
      setIncidents(prev =>
        prev.map(i =>
          i.id === vehicle.assignedIncidentId
            ? { ...i, assignedVehicleIds: i.assignedVehicleIds.filter(vid => vid !== vehicleId) }
            : i
        )
      );
      addLog(`S-${vehicleId.toString().padStart(2, '0')} S8‚ÜíS3 Umgeleitet zu neuem Einsatz`, 'assignment');
    }

    const station = policeStations.find(s => s.id === vehicle.stationId);
    if (!station) return;

    // Setze Fahrzeug auf S2 (Alarmierung) - noch nicht sichtbar auf Karte
    setVehicles(prev =>
      prev.map(v =>
        v.id === vehicleId ? {
          ...v,
          assignedIncidentId: incidentId,
          status: 'S2' as VehicleStatus,
          routeStartTime: Date.now(),
          routeProgress: 0,
          route: null,  // Wird async berechnet
          accumulatedTime: 0,  // Reset f√ºr neue Fahrt
        } : v
      )
    );

    // Route async berechnen, dann zu S3 wechseln
    (async () => {
      let route: [number, number][] | null = null;
      let routeDuration = 240;
      let routeDistance = 0;

      try {
        const osrmRoute = await getRoute(
          { lat: vehicle.position[0], lng: vehicle.position[1] },
          { lat: incident.position[0], lng: incident.position[1] }
        );

        if (osrmRoute) {
          route = convertToLeafletFormat(osrmRoute.coordinates);
          routeDistance = osrmRoute.distance;
          // ‚ö° WETTER-EFFEKT: Fahrzeuge langsamer bei schlechtem Wetter
          const weatherSpeedFactor = weatherConditions[weather.current].vehicleSpeedMultiplier;
          // ‚ö° M√úDIGKEITS-EFFEKT: Bei hoher M√ºdigkeit langsamer fahren
          const fatigueSpeedFactor = vehicle.crewFatigue > 80 ? 0.7 : 1.0; // 30% langsamer bei M√ºdigkeit >80%
          routeDuration = (osrmRoute.duration * 0.7) / (weatherSpeedFactor * fatigueSpeedFactor);
        } else {
          route = getStraightLineRoute(
            { lat: vehicle.position[0], lng: vehicle.position[1] },
            { lat: incident.position[0], lng: incident.position[1] }
          );
          routeDistance = calculateDistance(
            { lat: vehicle.position[0], lng: vehicle.position[1] },
            { lat: incident.position[0], lng: incident.position[1] }
          );
          // ‚ö° WETTER-EFFEKT anwenden
          const weatherSpeedFactor = weatherConditions[weather.current].vehicleSpeedMultiplier;
          // ‚ö° M√úDIGKEITS-EFFEKT
          const fatigueSpeedFactor = vehicle.crewFatigue > 80 ? 0.7 : 1.0;
          routeDuration = Math.max(60, routeDistance / 20) / (weatherSpeedFactor * fatigueSpeedFactor);
        }
      } catch (error) {
        console.error('OSRM Routing Fehler:', error);
        // Toast-Benachrichtigung bei OSRM-Fehler
        setToasts((prev) => [
          ...prev,
          {
            id: toastCounter,
            type: 'Routing Fehler',
            location: 'OSRM Server nicht erreichbar - Verwende Direktroute',
            priority: 'high',
            incidentId: 0,
          },
        ]);
        setToastCounter((prev) => prev + 1);

        // Fallback: Straight Line Route
        route = getStraightLineRoute(
          { lat: vehicle.position[0], lng: vehicle.position[1] },
          { lat: incident.position[0], lng: incident.position[1] }
        );
        routeDistance = calculateDistance(
          { lat: vehicle.position[0], lng: vehicle.position[1] },
          { lat: incident.position[0], lng: incident.position[1] }
        );
        routeDuration = Math.max(60, routeDistance / 20);
      }

      // Route fertig - wechsle zu S3 (Anfahrt)
      if (route) {
        setVehicles(prev => prev.map(v =>
          v.id === vehicleId ? {
            ...v,
            status: 'S3' as VehicleStatus,
            route: convertToLeafletFormat(route),
            routeDuration
          } : v
        ));
      }
    })();

    setIncidents(prev =>
      prev.map(i =>
        i.id === incidentId ? { ...i, assignedVehicleIds: [...i.assignedVehicleIds, vehicleId] } : i
      )
    );

    soundManager.playSirenBeep();
    // OPTIMIERUNG 2: Protocol-Log detaillierter (lstsim.de Style)
    addLog(`S-${vehicleId.toString().padStart(2, '0')} S1‚ÜíS3 Einsatz #${incidentId} ${incident.type}`, 'assignment');

    // ‚ö° FUNKSPRUCH: S8 ‚Üí S3 (Umleitung)
    addRadioMessage(vehicleId, 'S8', 'S3', {
      incidentType: incident.type,
      location: incident.locationName,
    });
  };

  // Vehicle movement animation and status management (Performance-Optimierung: nur wenn Fahrzeuge bewegt werden)
  useEffect(() => {
    if (!gameStarted || isPaused) return;

    let animationFrameId: number;
    let lastFrameTime = Date.now();

    const animate = () => {
      const currentFrameTime = Date.now();
      const deltaTime = (currentFrameTime - lastFrameTime) / 1000; // in seconds
      const scaledDeltaTime = deltaTime * gameSpeed; // Apply game speed multiplier
      lastFrameTime = currentFrameTime;

      // Performance-Check: Nur animieren wenn Fahrzeuge tats√§chlich unterwegs sind
      const hasMovingVehicles = vehicles.some(v => v.status === 'S3' || v.status === 'S8');

      if (!hasMovingVehicles) {
        // Keine Fahrzeuge unterwegs - schedule next frame anyway
        animationFrameId = requestAnimationFrame(animate);
        return;
      }

      setVehicles(prev =>
        prev.map(vehicle => {
          // S1: Bereit an Wache - no action needed
          if (vehicle.status === 'S1') {
            return vehicle;
          }

          // ‚ö° S6: Au√üer Dienst (Tanken/Pause/Reparatur)
          if (vehicle.status === 'S6' && vehicle.outOfServiceUntil) {
            // Pr√ºfe ob S6-Zeit vorbei ist
            if (gameTime >= vehicle.outOfServiceUntil) {
              // S6 ‚Üí S1: Zur√ºck im Dienst
              const updates = resetVehicleAfterService(vehicle, vehicle.outOfServiceReason || 'unknown');

              addLog(`S-${vehicle.id.toString().padStart(2, '0')} S6‚ÜíS1 ${vehicle.outOfServiceReason} abgeschlossen`, 'completion');

              return {
                ...vehicle,
                ...updates,
                status: 'S1',
                isAvailable: true,
              };
            }
            // Noch in S6
            return vehicle;
          }

          // S3: Anfahrt zum Einsatz
          if (vehicle.status === 'S3' && vehicle.route) {
            // Use accumulated elapsed time instead of Date.now()
            const accumulatedTime = vehicle.accumulatedTime || 0;
            const newAccumulatedTime = accumulatedTime + scaledDeltaTime;
            const newProgress = Math.min(newAccumulatedTime / vehicle.routeDuration, 1);

            if (newProgress >= 1) {
              // Arrived at incident - change to S4
              const incident = incidents.find(i => i.id === vehicle.assignedIncidentId);

              // Berechne Parking-Position: Fahrzeuge nebeneinander statt √ºbereinander
              const incidentVehicles = prev.filter(v =>
                v.assignedIncidentId === vehicle.assignedIncidentId && v.status === 'S4'
              );
              const parkingIndex = incidentVehicles.length; // Wieviele Fahrzeuge sind schon da?

              // Erstelle einen kleinen Offset um den Einsatzort herum (in einem Halbkreis)
              const incidentPos = vehicle.route[vehicle.route.length - 1];
              const offsetDistance = 0.0001; // ~11 Meter Abstand
              const angleStep = Math.PI / 4; // 45 Grad zwischen Fahrzeugen
              const angle = -Math.PI / 2 + (parkingIndex * angleStep); // Startwinkel -90¬∞ (oben)

              const parkedPosition: [number, number] = [
                incidentPos[0] + (Math.sin(angle) * offsetDistance),
                incidentPos[1] + (Math.cos(angle) * offsetDistance)
              ];

              setIncidents(prevIncidents =>
                prevIncidents.map(inc =>
                  inc.id === vehicle.assignedIncidentId
                    ? { ...inc, arrivedVehicles: inc.arrivedVehicles + 1 }
                    : inc
                )
              );

              // OPTIMIERUNG 2: Protocol-Log detaillierter (lstsim.de Style)
              addLog(`S-${vehicle.id.toString().padStart(2, '0')} S3‚ÜíS4 Einsatzort erreicht`, 'arrival');

              // ‚ö° FUNKSPRUCH: S3 ‚Üí S4 (Ankunft am Einsatzort)
              addRadioMessage(vehicle.id, 'S3', 'S4', {
                location: incident?.locationName,
              });

              return {
                ...vehicle,
                position: parkedPosition, // Geparkte Position mit Offset
                status: 'S4', // Am Einsatzort
                processingStartTime: Date.now(),
                processingDuration: incident?.processingDuration || 180,
                routeProgress: 1,
                situationReportSent: false, // Reset f√ºr Lagemeldung
              };
            }

            const { position: newPosition, bearing: newBearing } = getPointAlongRoute(vehicle.route, newProgress);

            return {
              ...vehicle,
              position: newPosition,
              routeProgress: newProgress,
              bearing: newBearing,
              accumulatedTime: newAccumulatedTime,
            };
          }

          // S4: Am Einsatzort - wait for processing to complete
          if (vehicle.status === 'S4' && vehicle.processingStartTime) {
            // Processing is handled in separate useEffect
            return vehicle;
          }

          // S8: R√ºckfahrt zur Wache
          if (vehicle.status === 'S8' && vehicle.route) {
            // Use accumulated elapsed time instead of Date.now()
            const accumulatedTime = vehicle.accumulatedTime || 0;
            const newAccumulatedTime = accumulatedTime + scaledDeltaTime;
            const newProgress = Math.min(newAccumulatedTime / vehicle.routeDuration, 1);

            if (newProgress >= 1) {
              // Arrived at station - change to S1
              const station = policeStations.find(s => s.id === vehicle.stationId);

              const routeDistance = vehicle.route?.length
                ? vehicle.route.reduce((total, point, index) => {
                    if (index === 0) return 0;
                    const prev = vehicle.route![index - 1];
                    return total + calculateDistance(
                      { lat: prev[0], lng: prev[1] },
                      { lat: point[0], lng: point[1] }
                    );
                  }, 0)
                : 0;

              // OPTIMIERUNG 2: Protocol-Log detaillierter (lstsim.de Style)
              addLog(`S-${vehicle.id.toString().padStart(2, '0')} S8‚ÜíS1 An Wache`, 'completion');

              // ‚ö° FUNKSPRUCH: S8 ‚Üí S1 (Ankunft an Wache)
              addRadioMessage(vehicle.id, 'S8', 'S1', {
                location: station?.name,
              });

              // ‚ö° REALISTISCHE TIMINGS: Verbrauch berechnen
              const distanceKm = routeDistance / 1000; // Meter ‚Üí Kilometer
              const fuelConsumed = calculateFuelConsumption(vehicle, distanceKm);
              const timeDrivenHours = vehicle.routeDuration / 3600; // Sekunden ‚Üí Stunden
              const fatigueGained = calculateCrewFatigue(vehicle, timeDrivenHours);
              const newFuelLevel = Math.max(0, vehicle.fuelLevel - fuelConsumed);
              const newFatigue = Math.min(100, vehicle.crewFatigue + fatigueGained);
              const newMaintenance = updateMaintenanceStatus(vehicle, distanceKm);

              // Pr√ºfe ob Fahrzeug zu S6 muss (Tanken/Pause/Reparatur)
              const updatedVehicle = {
                ...vehicle,
                fuelLevel: newFuelLevel,
                crewFatigue: newFatigue,
                maintenanceStatus: newMaintenance,
                totalDistanceTraveled: vehicle.totalDistanceTraveled + routeDistance,
              };

              const s6Reason = determineOutOfServiceReason(updatedVehicle);
              const shouldGoS6 = s6Reason !== null;

              return {
                ...updatedVehicle,
                position: station ? station.position : vehicle.position,
                assignedIncidentId: null,
                routeIndex: 0,
                route: null,
                routeProgress: 0,
                bearing: 0,
                routeDuration: 0,
                routeStartTime: 0,
                status: shouldGoS6 ? 'S6' : 'S1',
                processingStartTime: null,
                processingDuration: 0,
                outOfServiceReason: shouldGoS6 ? s6Reason : null,
                outOfServiceUntil: shouldGoS6 ? calculateOutOfServiceDuration(s6Reason!, gameTime) : null,
              };
            }

            const { position: newPosition, bearing: newBearing } = getPointAlongRoute(vehicle.route, newProgress);

            return {
              ...vehicle,
              position: newPosition,
              routeProgress: newProgress,
              bearing: newBearing,
              accumulatedTime: newAccumulatedTime,
            };
          }

          return vehicle;
        })
      );

      animationFrameId = requestAnimationFrame(animate);
    };

    // Starte Animation
    animationFrameId = requestAnimationFrame(animate);

    return () => {
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
      }
    };
  }, [gameStarted, isPaused, gameSpeed, incidents, vehicles]);

  // Handle S4 processing and transition to S8 (Optimierung: nur wenn Fahrzeuge am Einsatzort sind)
  useEffect(() => {
    if (!gameStarted) return;

    // Performance-Check: Nur laufen wenn Fahrzeuge Status S4 haben
    const hasProcessingVehicles = vehicles.some(v => v.status === 'S4');
    if (!hasProcessingVehicles) return;

    const interval = setInterval(() => {
      setVehicles(prev =>
        prev.map(vehicle => {
          if (vehicle.status === 'S4' && vehicle.processingStartTime) {
            const currentTime = Date.now();
            const processingElapsed = (currentTime - vehicle.processingStartTime) / 1000;

            // ‚ö° R√úCKMELDUNGS-SYSTEM: Lagemeldung nach 10-20 Sekunden (LST-SIM Style)
            if (!vehicle.situationReportSent && processingElapsed >= 10 && processingElapsed <= 20) {
              const incident = incidents.find(i => i.id === vehicle.assignedIncidentId);
              if (incident) {
                // Generiere realistische Lagemeldung
                const situationReports = [
                  `Lage vor Ort best√§tigt. ${incident.type}. Ma√ünahmen werden eingeleitet.`,
                  `Einsatzort erreicht. Situation wie gemeldet. Beginne mit Ma√ünahmen.`,
                  `Am Einsatzort. ${incident.type} best√§tigt. Ben√∂tige ca. ${Math.ceil(vehicle.processingDuration / 60)} Minuten.`,
                  `Vor Ort. Lage entspricht Meldung. Weitere Updates folgen.`,
                ];
                const report = situationReports[Math.floor(Math.random() * situationReports.length)];

                addRadioMessage(vehicle.id, 'S4', 'S4', {
                  customMessage: report,
                  requiresResponse: false,
                });

                return { ...vehicle, situationReportSent: true };
              }
            }

            // ‚ö° SPRECHWUNSCH-SYSTEM (S5): Zuf√§llige Chance w√§hrend S4
            // 10% Chance f√ºr Sprechwunsch zwischen 50% und 80% der Processing-Zeit
            const processingProgress = processingElapsed / vehicle.processingDuration;
            if (
              processingProgress > 0.5 &&
              processingProgress < 0.8 &&
              !vehicle.speakRequest &&
              Math.random() < 0.01 // 1% pro Sekunde = ~15-20% Chance insgesamt
            ) {
              // Generiere zuf√§lligen Sprechwunsch
              const speakReasons: SpeakRequestReason[] = [
                'backup',
                'escalation',
                'suspect_arrested',
                'additional_info',
                'unclear_situation',
              ];
              const reason = speakReasons[Math.floor(Math.random() * speakReasons.length)];
              const message = speakRequestMessages[reason];



              setVehicles(prevVehicles =>
                prevVehicles.map(v =>
                  v.id === vehicle.id
                    ? {
                        ...v,
                        status: 'S5' as VehicleStatus,
                        speakRequest: message,
                      }
                    : v
                )
              );

              addLog(`S-${vehicle.id.toString().padStart(2, '0')} S4‚ÜíS5 ${message}`, 'assignment');

              // ‚ö° FUNKSPRUCH: S4 ‚Üí S5 (Sprechwunsch)
              addRadioMessage(vehicle.id, 'S4', 'S5', {
                customMessage: message,
                requiresResponse: true, // Sprechwunsch muss beantwortet werden!
              });

              soundManager.playAlertSound();

              return vehicle; // Behalte alten Status f√ºr diesen Frame
            }

            if (processingElapsed >= vehicle.processingDuration) {
              // Check if all required vehicles have arrived and processed
              const incident = incidents.find(i => i.id === vehicle.assignedIncidentId);
              if (incident && incident.arrivedVehicles >= incident.requiredVehicles) {
                // All vehicles ready - start return trip
                const station = policeStations.find(s => s.id === vehicle.stationId);
                if (!station) return vehicle;

                // Get route back to station
                getRoute(
                  { lat: vehicle.position[0], lng: vehicle.position[1] },
                  { lat: station.position[0], lng: station.position[1] }
                ).then(osrmRoute => {
                  let returnRoute: [number, number][] | null = null;
                  let returnDuration = 240;

                  if (osrmRoute) {
                    returnRoute = convertToLeafletFormat(osrmRoute.coordinates);
                    returnDuration = osrmRoute.duration * 0.7;
                  } else {
                    returnRoute = getStraightLineRoute(
                      { lat: vehicle.position[0], lng: vehicle.position[1] },
                      { lat: station.position[0], lng: station.position[1] }
                    );
                    const returnDistance = calculateDistance(
                      { lat: vehicle.position[0], lng: vehicle.position[1] },
                      { lat: station.position[0], lng: station.position[1] }
                    );
                    returnDuration = Math.max(60, returnDistance / 20);
                  }

                  setVehicles(prevVehicles =>
                    prevVehicles.map(v =>
                      v.id === vehicle.id
                        ? {
                            ...v,
                            status: 'S8', // R√ºckfahrt zur Wache
                            route: returnRoute,
                            routeProgress: 0,
                            routeStartTime: Date.now(),
                            routeDuration: returnDuration,
                            accumulatedTime: 0,  // Reset f√ºr R√ºckfahrt
                          }
                        : v
                    )
                  );

                  // OPTIMIERUNG 2: Protocol-Log detaillierter (lstsim.de Style)
                  addLog(`S-${vehicle.id.toString().padStart(2, '0')} S4‚ÜíS8 R√ºckkehr zur Wache`, 'completion');

                  // ‚ö° FUNKSPRUCH: S4 ‚Üí S8 (Einsatz beendet, R√ºckkehr)
                  addRadioMessage(vehicle.id, 'S4', 'S8', {
                    location: station?.name,
                  });
                });
              }

              return vehicle;
            }
          }

          return vehicle;
        })
      );
    }, 1000);

    return () => clearInterval(interval);
  }, [gameStarted, incidents, vehicles]);

  // Eskalations-System (Optimierung: nur wenn eskalationsf√§hige Eins√§tze vorhanden sind)
  useEffect(() => {
    if (!gameStarted) return;

    // Performance-Check: Nur laufen wenn eskalationsf√§hige Eins√§tze vorhanden sind
    const hasEscalatableIncidents = incidents.some(i => i.canEscalate && !i.hasEscalated);
    if (!hasEscalatableIncidents) return;

    const interval = setInterval(() => {
      setIncidents(prev =>
        prev.map(incident => {
          // Pr√ºfe ob Einsatz eskalieren soll
          if (
            incident.canEscalate &&
            !incident.hasEscalated &&
            incident.escalationTime &&
            Date.now() >= incident.escalationTime &&
            incident.assignedVehicleIds.length > 0 && // Nur wenn Fahrzeuge unterwegs
            (vehicles.some(v => v.assignedIncidentId === incident.id && (v.status === 'S3' || v.status === 'S4')))
          ) {
            const escalation = escalationRules[incident.type];
            if (escalation) {
              const newType = escalation.newType;
              const newPriority = escalation.newPriority;
              const escalatedIncidentType = incidentTypes.find(it => it.type === newType);

              if (escalatedIncidentType) {
                // Eskalations-Benachrichtigung
                soundManager.playAlertSound();
                addLog(`‚ö†Ô∏è ESKALATION: ${incident.type} ‚Üí ${newType} in ${incident.locationName}`, 'new');

                setToasts((prevToasts) => [
                  ...prevToasts,
                  {
                    id: toastCounter,
                    type: `‚ö†Ô∏è ESKALATION: ${newType}`,
                    location: incident.locationName,
                    priority: newPriority,
                    incidentId: incident.id,
                  },
                ]);
                setToastCounter((prev) => prev + 1);

                // Aktualisiere Einsatz
                return {
                  ...incident,
                  type: newType,
                  priority: newPriority,
                  description: `${escalatedIncidentType.description} - ${incident.locationName}`,
                  requiredVehicles: incident.requiredVehicles + 1,
                  timeRemaining: incident.timeRemaining + 30,
                  processingDuration: incidentProcessingTimes[newType] || incident.processingDuration,
                  hasEscalated: true,
                  canEscalate: false,
                };
              }
            }
          }

          return incident;
        })
      );
    }, 1000);

    return () => clearInterval(interval);
  }, [gameStarted, vehicles, incidents]);

  // Incident completion check (Optimierung: nur wenn aktive Eins√§tze vorhanden sind)
  useEffect(() => {
    if (!gameStarted) return;

    // Performance-Check: Nur laufen wenn Eins√§tze vorhanden sind
    if (incidents.length === 0) return;

    const interval = setInterval(() => {
      setIncidents(prev => {
        const updated = prev.map(incident => {
          // Check if all required vehicles have arrived
          if (incident.arrivedVehicles >= incident.requiredVehicles) {
            // KRITISCHER BUGFIX (lstsim.de Style): Einsatz ist ERST abgeschlossen wenn ALLE Fahrzeuge in S8 sind!
            const incidentVehicles = vehicles.filter(v => v.assignedIncidentId === incident.id);
            const allReturning = incidentVehicles.every(v => v.status === 'S8');

            if (allReturning && incidentVehicles.length > 0) {
              // All vehicles are returning - complete incident
              const responseTime = (Date.now() - incident.spawnTime) / 1000;
              const points = incident.priority === 'high' ? 30 : incident.priority === 'medium' ? 20 : 10;
              const bonus = incident.requiredVehicles > 1 ? incident.requiredVehicles * 10 : 0;

              setScore(s => s + points + bonus);

              setStatistics(prev => ({
                ...prev,
                totalResolved: prev.totalResolved + 1,
                totalResponseTimes: [...prev.totalResponseTimes, responseTime],
                incidentsByType: {
                  ...prev.incidentsByType,
                  [incident.type]: (prev.incidentsByType[incident.type] || 0) + 1,
                },
                currentStreak: prev.currentStreak + 1,
                bestStreak: Math.max(prev.bestStreak, prev.currentStreak + 1),
                totalDistance: prev.totalDistance + vehicles.reduce((sum, v) => sum + v.totalDistanceTraveled, 0),
              }));

              soundManager.playSuccessChime();
              addLog(`Einsatz ${incident.type} in ${incident.locationName} erfolgreich abgeschlossen (+${points + bonus} Punkte)`, 'completion');

              return null;
            }
          }

          // Decrement timer if not all vehicles assigned
          if (incident.assignedVehicleIds.length < incident.requiredVehicles) {
            return { ...incident, timeRemaining: incident.timeRemaining - 1 };
          }

          return incident;
        }).filter(i => {
          if (i === null) return false;
          if (i.timeRemaining <= 0) {
            setStatistics(prev => ({
              ...prev,
              totalFailed: prev.totalFailed + 1,
              currentStreak: 0,
            }));
            soundManager.playFailureSound();
            addLog(`Einsatz ${i.type} in ${i.locationName} fehlgeschlagen (Zeit abgelaufen)`, 'failed');
            return false;
          }
          return true;
        }) as Incident[];

        return updated;
      });
    }, 1000);

    return () => clearInterval(interval);
  }, [gameStarted, vehicles]);

  // Generate new incidents periodically (lstsim.de style: based on incidents per hour)
  // BUGFIX: Memory Leak behoben - setTimeout Cleanup hinzugef√ºgt
  useEffect(() => {
    if (!gameStarted) return;

    const settings = getDifficultySettings();
    let isCancelled = false; // Flag um Timeout-Kette zu stoppen
    const timeouts: ReturnType<typeof setTimeout>[] = []; // Array f√ºr alle aktiven Timeouts

    // lstsim.de: Berechne Intervall basierend auf Eins√§tzen pro Stunde
    // Formel: (3600 Sekunden / Eins√§tze pro Stunde) √ó Zufallsfaktor (0.7-1.3)
    const baseInterval = (3600 / settings.incidentsPerHour) * 1000; // In Millisekunden

    const scheduleNextIncident = () => {
      if (isCancelled) return; // Stoppe wenn cancelled

      // Rush hour multiplier (7-9 Uhr und 17-19 Uhr)
      const hour = Math.floor(gameTime / 60);
      const isRushHour = (hour >= 7 && hour <= 9) || (hour >= 17 && hour <= 19);
      const rushHourMultiplier = isRushHour ? 0.7 : 1; // Mehr Eins√§tze = k√ºrzeres Intervall

      // ‚ö° WETTER-EFFEKT: Mehr Eins√§tze bei schlechtem Wetter
      const weatherMultiplier = 1 / weatherConditions[weather.current].incidentMultiplier;
      // z.B. Regen (1.2x Eins√§tze) = 1/1.2 = 0.83 (k√ºrzeres Intervall)

      // üé≤ MAXIMALE VARIATION: Zuf√§lliger Faktor (0.4-1.8 f√ºr h√∂here Unvorhersehbarkeit!)
      const randomFactor = 0.4 + Math.random() * 1.4;

      // Berechne n√§chstes Intervall (MIT WETTER-EFFEKT und hoher Variation!)
      const nextInterval = baseInterval * rushHourMultiplier * weatherMultiplier * randomFactor;

      const timeout = setTimeout(() => {
        if (!isCancelled && incidents.length < settings.maxIncidents) {
          generateIncident();
        }
        scheduleNextIncident(); // Schedule next incident
      }, nextInterval);

      timeouts.push(timeout);
    };

    // üé≤ Start initial incident mit MAXIMALER Variation
    const initialDelay = baseInterval * (0.1 + Math.random() * 0.8); // 10-90% of base interval
    const initialTimeout = setTimeout(() => {
      if (!isCancelled) {
        generateIncident();
        scheduleNextIncident();
      }
    }, initialDelay);

    timeouts.push(initialTimeout);

    // Cleanup: Stoppe alle Timeouts wenn Component unmounted oder gameStarted sich √§ndert
    return () => {
      isCancelled = true;
      timeouts.forEach(timeout => clearTimeout(timeout));
    };
  }, [gameStarted]);

  // Game time progression (mit Geschwindigkeit und Pause)
  useEffect(() => {
    if (!gameStarted || isPaused) return;

    // Intervall basierend auf Geschwindigkeit: 10s (1x), 5s (2x), 3.33s (3x), 2.5s (4x)
    const baseInterval = 10000 / gameSpeed;

    const interval = setInterval(() => {
      setGameTime((prev) => prev + 1);
    }, baseInterval);

    return () => clearInterval(interval);
  }, [gameStarted, gameSpeed, isPaused]);

  // Berechnete Werte M√úSSEN VOR allen useEffects stehen die sie verwenden
  const hours = Math.floor(gameTime / 60);
  const minutes = Math.floor(gameTime % 60);
  const formattedTime = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;

  // Weather change logic - MUSS VOR if (!gameStarted) sein
  useEffect(() => {
    if (!gameStarted || isPaused) return;

    const checkWeatherChange = () => {
      if (gameTime >= weather.nextChange) {
        const newWeather = weather.forecast;
        const duration = getWeatherDuration(newWeather);
        const forecast = getNextWeather(newWeather, hours);

        setWeather({
          current: newWeather,
          duration,
          nextChange: gameTime + duration,
          forecast,
        });

        addLog(`Wetter √§ndert sich: ${weatherConditions[newWeather].name}`, 'new' as const);
      }
    };

    checkWeatherChange();
  }, [gameTime, gameStarted, isPaused, weather, hours]);

  // Get status badge color and text (lstsim.de Style - ERWEITERT)
  const getStatusBadge = (status: VehicleStatus) => {
    const badges = {
      'S1': { color: '#30D158', text: 'S1 Bereit', short: 'S1' },
      'S3': { color: '#FF9F0A', text: 'S3 Anfahrt', short: 'S3' },
      'S4': { color: '#FF453A', text: 'S4 Einsatzort', short: 'S4' },
      'S5': { color: '#0A84FF', text: 'S5 Sprechwunsch', short: 'S5' },
      'S6': { color: '#8E8E93', text: 'S6 Au√üer Dienst', short: 'S6' },
      'S7': { color: '#FFD60A', text: 'S7 Tanken', short: 'S7' },
      'S8': { color: '#0A84FF', text: 'S8 R√ºckfahrt', short: 'S8' },
    };
    return badges[status];
  };

  if (!gameStarted) {
    return (
      <div className="station-selection">
        <div className="start-screen-header">
          <img src="/polizeistern-hessen.svg" alt="Polizeistern Hessen" width="96" height="96" className="header-logo" />
          <h1>POLIZEI HESSEN</h1>
          <h2>Einsatzleitsystem Frankfurt</h2>
          <div className="header-divider"></div>
        </div>

        <div className="game-settings">
          <div className="setting-group">
            <label>Schwierigkeit</label>
            <div className="difficulty-buttons">
              <button
                className={`difficulty-btn ${difficulty === 'Leicht' ? 'active' : ''}`}
                onClick={() => setDifficulty('Leicht')}
              >
                Leicht
              </button>
              <button
                className={`difficulty-btn ${difficulty === 'Mittel' ? 'active' : ''}`}
                onClick={() => setDifficulty('Mittel')}
              >
                Mittel
              </button>
              <button
                className={`difficulty-btn ${difficulty === 'Schwer' ? 'active' : ''}`}
                onClick={() => setDifficulty('Schwer')}
              >
                Schwer
              </button>
            </div>
          </div>

          <div className="setting-group">
            <label>Schichtbeginn</label>
            <div className="custom-dropdown">
              <button
                className="dropdown-toggle"
                onClick={() => setIsTimeDropdownOpen(!isTimeDropdownOpen)}
              >
                <span>{selectedTime.toString().padStart(2, '0')}:00 Uhr</span>
                <span className="dropdown-arrow">{isTimeDropdownOpen ? '‚ñ¥' : '‚ñæ'}</span>
              </button>
              {isTimeDropdownOpen && (
                <div className="dropdown-menu">
                  {Array.from({ length: 24 }, (_, i) => (
                    <button
                      key={i}
                      className={`dropdown-item ${selectedTime === i ? 'active' : ''}`}
                      onClick={() => {
                        setSelectedTime(i);
                        setIsTimeDropdownOpen(false);
                      }}
                    >
                      {i.toString().padStart(2, '0')}:00 Uhr
                    </button>
                  ))}
                </div>
              )}
            </div>
          </div>
        </div>

        <div className="station-section">
          <h3 className="section-title">Polizeiwache ausw√§hlen</h3>
          <div className="station-grid">
            {policeStations.map(station => (
              <div
                key={station.id}
                className="station-card"
                onClick={() => startGame(station.id)}
              >
                <img className="station-icon-large" src="/polizeistern-hessen.svg" alt="Polizeirevier" width="48" height="48" />
                <h3>{station.name}</h3>
                <div className="station-start-btn">Schicht beginnen</div>
              </div>
            ))}
          </div>
        </div>

        {achievements.filter(a => a.unlocked).length > 0 && (
          <div className="achievements-section">
            <h3 className="achievements-title">
              Erfolge {achievements.filter(a => a.unlocked).length}/{achievements.length}
            </h3>
            <div className="achievements-grid">
              {achievements.map(achievement => (
                <div
                  key={achievement.id}
                  className={`achievement-badge ${achievement.unlocked ? 'unlocked' : 'locked'}`}
                  title={achievement.description}
                >
                  <span style={{ fontSize: '24px' }}>{achievement.icon}</span>
                </div>
              ))}
            </div>
          </div>
        )}
      </div>
    );
  }

  const selectedStationData = policeStations.find(s => s.id === selectedStation);

  // Bestimme automatisch Dark Mode basierend auf Tageszeit
  const isDarkMode = hours >= 20 || hours < 6;

  // Immer OpenStreetMap verwenden
  const mapTileUrl = 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';
  const mapAttribution = '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors';

  // Count vehicles by status for filter display
  const vehicleStatusCounts = {
    S1: vehicles.filter(v => v.status === 'S1').length,
    S2: vehicles.filter(v => v.status === 'S2').length,
    S3: vehicles.filter(v => v.status === 'S3').length,
    S4: vehicles.filter(v => v.status === 'S4').length,
    S5: vehicles.filter(v => v.status === 'S5').length,
    S6: vehicles.filter(v => v.status === 'S6').length,
    S7: vehicles.filter(v => v.status === 'S7').length,
    S8: vehicles.filter(v => v.status === 'S8').length,
  };

  return (
    <div className="app">
      {/* NEW LAYOUT: Map on left, right panel split into vehicles (top) and calls (bottom) */}
      <div className="main-layout">
        {/* LEFT: Full Map */}
        <div className="map-container">
          {/* Wetter-Overlay */}
          {weather.current !== 'sunny' && (
            <div className={`weather-overlay ${getWeatherOverlayClass(weather.current)}`} />
          )}
          <MapContainer
            center={mapCenter}
            zoom={13}
            style={{ height: '100%', width: '100%' }}
            className={isDarkMode ? 'map-dark-google' : ''}
          >
            <MapCenterUpdater center={mapCenter} zoom={mapZoom} />
            <TileLayer
              attribution={mapAttribution}
              url={mapTileUrl}
              maxZoom={20}
            />

            {policeStations.map(station => (
              <Marker
                key={station.id}
                position={station.position}
                icon={createStationIcon()}
              >
                <Popup>{station.name}</Popup>
              </Marker>
            ))}

            {/* Gas Stations */}
            {gasStations.map(station => (
              <Marker
                key={`gas-${station.id}`}
                position={station.position}
                icon={createGasStationIcon()}
              >
                <Popup>
                  <strong>‚õΩ {station.name}</strong><br/>
                  {station.brand}
                </Popup>
              </Marker>
            ))}

            {incidents.map(incident => (
              <Marker
                key={incident.id}
                position={incident.position}
                icon={createIncidentIcon(incident.priority, incident.hasEscalated)}
              >
                <Popup>
                  <strong>{incident.type}</strong>
                  {incident.hasEscalated && <span style={{ color: '#FF453A', marginLeft: '8px' }}>‚ö†Ô∏è ESKALIERT</span>}
                  <br />
                  {incident.description}
                  <br />
                  Zeit: {incident.timeRemaining}s
                  <br />
                  Bearbeitung: {Math.floor(incident.processingDuration / 60)} Min
                </Popup>
              </Marker>
            ))}

            {vehicles
              .filter(vehicle => {
                // Verstecke Fahrzeuge an der Wache (S1)
                if (vehicle.status === 'S1') return false;
                // Verstecke alarmierte Fahrzeuge (S2 - bereiten Ausr√ºckung vor)
                if (vehicle.status === 'S2') return false;
                // Verstecke S3-Fahrzeuge die noch nicht losgefahren sind
                // (S3 ohne Route ODER S3 mit Route aber noch kein Fortschritt)
                if (vehicle.status === 'S3' && (!vehicle.route || vehicle.routeProgress === 0)) return false;
                // Zeige alle anderen
                return true;
              })
              .map(vehicle => {
              return (
                <React.Fragment key={vehicle.id}>
                  <VehicleMarker
                    position={vehicle.position}
                    bearing={vehicle.bearing}
                    status={vehicle.status}
                    vehicle={vehicle}
                  />

                  {vehicle.route && vehicle.route.length > 0 && (
                    <Polyline
                      positions={vehicle.route}
                      color={vehicle.status === 'S3' ? '#FF453A' : '#0A84FF'} // Rot f√ºr Hinfahrt, Blau f√ºr R√ºckfahrt
                      weight={4}
                      opacity={0.7}
                    />
                  )}
                </React.Fragment>
              );
            })}
          </MapContainer>
        </div>

        {/* RIGHT: Three-Column Layout wie lstsim.de */}
        <div className="right-panel-lstsim">
          {/* LEFT COLUMN: Fahrzeuge */}
          <div className="vehicle-list-panel">
            <div className="panel-header">
              <h3>Fahrzeuge</h3>
              <div className="vehicle-filters">
                <button
                  className={`filter-btn ${vehicleFilter === 'all' ? 'active' : ''}`}
                  onClick={() => setVehicleFilter('all')}
                  title="Alle Fahrzeuge"
                >
                  Alle
                </button>
                <button
                  className={`filter-btn ${vehicleFilter === 'S1' ? 'active' : ''}`}
                  onClick={() => setVehicleFilter('S1')}
                  title="Nur S1 (Bereit)"
                  style={{ color: '#30D158' }}
                >
                  S1 ({vehicleStatusCounts.S1})
                </button>
                <button
                  className={`filter-btn ${vehicleFilter === 'S3' ? 'active' : ''}`}
                  onClick={() => setVehicleFilter('S3')}
                  title="Nur S3 (Anfahrt)"
                  style={{ color: '#FF9F0A' }}
                >
                  S3 ({vehicleStatusCounts.S3})
                </button>
                <button
                  className={`filter-btn ${vehicleFilter === 'S4' ? 'active' : ''}`}
                  onClick={() => setVehicleFilter('S4')}
                  title="Nur S4 (Einsatzort)"
                  style={{ color: '#FF453A' }}
                >
                  S4 ({vehicleStatusCounts.S4})
                </button>
              </div>
            </div>
            <div className="panel-content">
              {[...vehicles]
                .filter(v => vehicleFilter === 'all' || v.status === vehicleFilter)
                .sort((a, b) => {
                  const statusOrder: { [key in VehicleStatus]: number } = { S1: 1, S3: 2, S4: 3, S5: 4, S6: 5, S7: 6, S8: 7 };
                  return statusOrder[a.status] - statusOrder[b.status];
                })
                .map(vehicle => {
                  const statusInfo = getStatusBadge(vehicle.status);
                  const incident = incidents.find(i => i.id === vehicle.assignedIncidentId);
                  const vehicleConfig = vehicleTypeConfigs[vehicle.vehicleType];

                  return (
                    <div
                      key={vehicle.id}
                      className={`vehicle-list-item ${selectedVehicleId === vehicle.id ? 'selected' : ''}`}
                      onClick={() => {
                        setMapCenter(vehicle.position);
                        setMapZoom(17);
                        setSelectedVehicleId(vehicle.id);
                        soundManager.playSirenBeep();
                      }}
                    >
                      <div className="vehicle-list-left">
                        <span className="vehicle-icon">{vehicleConfig.icon}</span>
                        <span className="vehicle-name">{vehicleConfig.displayName} {vehicle.id}</span>
                        <span className="vehicle-status-icon" style={{ background: statusInfo.color }}></span>
                      </div>
                      {incident && (
                        <div className="vehicle-list-incident">
                          {incident.type} ‚Ä¢ {incident.locationName}
                        </div>
                      )}
                      {vehicle.status === 'S8' && vehicle.canBeRedirected && (
                        <div className="vehicle-redirect-hint">‚Üª Kann umgeleitet werden</div>
                      )}
                    </div>
                  );
                })}
            </div>
          </div>

          {/* MIDDLE COLUMN: Eins√§tze (lstsim.de Style) */}
          <div className="incidents-panel-lstsim">
            <div className="panel-header">
              <h3>Aktive Eins√§tze ({incidents.length})</h3>
            </div>
            <div className="panel-content">
              {incidents.length === 0 && (
                <div className="empty-state">Keine aktiven Eins√§tze</div>
              )}
              {incidents.map(incident => {
                const minETA = calculateMinETA(incident, vehicles);
                const assignedVehicles = vehicles.filter(v => incident.assignedVehicleIds.includes(v.id));
                const availableVehicles = vehicles.filter(v => v.status === 'S1' || (v.status === 'S8' && v.canBeRedirected));

                return (
                  <div key={incident.id} className={`incident-card-lstsim priority-${incident.priority}`}>
                    <div className="incident-card-header">
                      <div className="incident-card-title">
                        {incident.hasEscalated && <span className="escalation-badge">!</span>}
                        <strong>{incident.type}</strong>
                        <span className={`priority-badge-lstsim priority-${incident.priority}`}>
                          {incident.priority === 'high' ? 'DRINGEND' : incident.priority === 'medium' ? 'NORMAL' : 'NIEDRIG'}
                        </span>
                      </div>
                      <span className="time-remaining-large">{incident.timeRemaining}s</span>
                    </div>

                    <div className="incident-location-lstsim">
                      {incident.locationName}
                    </div>

                    {/* MANV Progress-Bar */}
                    {incident.isMANV && (
                      <div className="manv-progress-container">
                        <div className="manv-progress-label">
                          üö® MANV-Sichtung: {incident.manvTriageProgress || 0}%
                        </div>
                        <div className="manv-progress-bar">
                          <div
                            className="manv-progress-fill"
                            style={{ width: `${incident.manvTriageProgress || 0}%` }}
                          >
                            {incident.manvTriageProgress && incident.manvTriageProgress > 20 ? `${Math.round(incident.manvTriageProgress)}%` : ''}
                          </div>
                        </div>
                        <div className="manv-info">
                          Beteiligte: {incident.involvedCount || 0} ‚Ä¢ Vor Ort: {incident.arrivedVehicles}/{incident.requiredVehicles}
                        </div>
                      </div>
                    )}

                    <div className="incident-status-row">
                      <span>Fahrzeuge: {incident.arrivedVehicles}/{incident.requiredVehicles}</span>
                      {minETA > 0 && <span>ETA: {Math.ceil(minETA)} Min</span>}
                      <button
                        className="map-center-btn"
                        onClick={() => { setMapCenter(incident.position); setMapZoom(16); }}
                        title="Auf Karte zentrieren und heranzoomen"
                      >
                        ‚äï
                      </button>
                    </div>

                    {/* Zugewiesene Fahrzeuge */}
                    {assignedVehicles.length > 0 && (
                      <div className="assigned-vehicles-list">
                        {assignedVehicles.map(v => {
                          const config = vehicleTypeConfigs[v.vehicleType];
                          const statusInfo = getStatusBadge(v.status);
                          return (
                            <div key={v.id} className="assigned-vehicle-chip">
                              {config.icon} {v.id} <span style={{color: statusInfo.color}}>‚óè</span>
                            </div>
                          );
                        })}
                      </div>
                    )}

                    {/* Fahrzeugzuweisung - Kollabierbar */}
                    {incident.assignedVehicleIds.length < incident.requiredVehicles && (
                      <div className="vehicle-assignment-collapsible">
                        <button
                          className="toggle-vehicle-assignment-btn"
                          onClick={() => {
                            setExpandedIncidents(prev => {
                              const newSet = new Set(prev);
                              if (newSet.has(incident.id)) {
                                newSet.delete(incident.id);
                              } else {
                                newSet.add(incident.id);
                              }
                              return newSet;
                            });
                          }}
                        >
                          <span className="toggle-icon">{expandedIncidents.has(incident.id) ? '‚ñº' : '‚ñ∂'}</span>
                          Weitere Fahrzeuge zuweisen
                          <span className="available-count-badge">({availableVehicles.length})</span>
                        </button>

                        {/* Smart Assignment Button */}
                        <button
                          className="auto-assign-btn"
                          onClick={() => {
                            const { recommended, warnings } = getAutoAssignmentRecommendations(vehicles, incident);
                            if (recommended.length > 0) {
                              const best = recommended[0];
                              assignVehicle(best.vehicleId, incident.id);
                              addLog(`üéØ Auto-Assign: Fahrzeug ${best.vehicleId} (Score: ${best.score.toFixed(0)}/100)`, 'assignment');
                              if (warnings.length > 0) {
                                warnings.forEach(w => addLog(`‚ö†Ô∏è ${w}`, 'system'));
                              }
                            } else {
                              addLog(`‚ö†Ô∏è Kein geeignetes Fahrzeug f√ºr ${incident.type} verf√ºgbar`, 'system');
                            }
                          }}
                          disabled={availableVehicles.length === 0}
                          title="Bestes verf√ºgbares Fahrzeug automatisch zuweisen"
                        >
                          üéØ Auto-Assign
                        </button>

                        {expandedIncidents.has(incident.id) && (
                          <div className="vehicle-assignment-expanded">
                            <div className="vehicle-assignment-full-list">
                              {vehicles.map(v => {
                                const config = vehicleTypeConfigs[v.vehicleType];
                                const isAvailable = v.status === 'S1' || (v.status === 'S8' && v.canBeRedirected);
                                const isAlreadyAssigned = incident.assignedVehicleIds.includes(v.id);
                                const statusBadge = getStatusBadge(v.status);

                                // Berechne Entfernung zum Einsatzort
                                const distance = calculateDistance(
                                  { lat: v.position[0], lng: v.position[1] },
                                  { lat: incident.position[0], lng: incident.position[1] }
                                );
                                const distanceKm = (distance / 1000).toFixed(1);
                                const estimatedTime = Math.ceil((distance / 1000) / 60 * 60); // ~60 km/h Durchschnitt

                                return (
                                  <button
                                    key={v.id}
                                    onClick={() => isAvailable && !isAlreadyAssigned && assignVehicle(v.id, incident.id)}
                                    className={`assign-vehicle-card ${isAvailable && !isAlreadyAssigned ? 'available' : 'unavailable'} ${isAlreadyAssigned ? 'already-assigned' : ''}`}
                                    disabled={!isAvailable || isAlreadyAssigned}
                                    title={
                                      isAlreadyAssigned
                                        ? 'Bereits diesem Einsatz zugewiesen'
                                        : isAvailable
                                        ? `${config.displayName} ${v.id} zuweisen - ${distanceKm} km entfernt`
                                        : `Nicht verf√ºgbar (${statusBadge.text})`
                                    }
                                  >
                                    <div className="assign-vehicle-icon-badge">{config.icon}</div>
                                    <div className="assign-vehicle-details">
                                      <div className="assign-vehicle-name">
                                        {config.displayName} {v.id}
                                      </div>
                                      <div
                                        className="assign-vehicle-status"
                                        style={{ color: statusBadge.color }}
                                      >
                                        ‚óè {statusBadge.short}
                                        {v.status === 'S8' && v.canBeRedirected && ' (‚Üª)'}
                                      </div>
                                      <div className="assign-vehicle-distance">
                                        üìç {distanceKm} km ‚Ä¢ ~{estimatedTime} Min
                                      </div>
                                    </div>
                                    {isAlreadyAssigned && <div className="assigned-check">‚úì</div>}
                                  </button>
                                );
                              })}
                            </div>
                            {availableVehicles.length === 0 && (
                              <div className="no-vehicles-warning">‚ö†Ô∏è Keine Fahrzeuge verf√ºgbar</div>
                            )}
                          </div>
                        )}
                      </div>
                    )}

                    {/* Verst√§rkung Button */}
                    <button
                      className="backup-button"
                      onClick={() => requestBackup(incident.id)}
                      title="Zus√§tzliches Fahrzeug anfordern"
                    >
                      + Verst√§rkung
                    </button>
                  </div>
                );
              })}
            </div>
          </div>

          {/* RIGHT COLUMN: Funkverkehr (Funkspr√ºche & Sprechw√ºnsche kombiniert) */}
          <div className="calls-and-speaks-panel">
            {/* Kombiniertes Funkverkehr-Fenster */}
            <div className="radio-section-combined">
              <div className="panel-header-small">
                <h4>üìª Funkverkehr</h4>
                <span className="radio-count-badge">
                  {radioMessages.length} Meldungen
                  {vehicles.filter(v => v.status === 'S5').length > 0 && (
                    <span className="speak-request-indicator"> ‚Ä¢ {vehicles.filter(v => v.status === 'S5').length} Sprechwunsch</span>
                  )}
                </span>
              </div>
              <div className="panel-content-small radio-combined-content">
                {/* Sprechw√ºnsche oben (wichtig) */}
                {vehicles.filter(v => v.status === 'S5').map(vehicle => {
                  const config = vehicleTypeConfigs[vehicle.vehicleType];
                  return (
                    <div key={vehicle.id} className="speak-request-item-inline">
                      <div className="speak-inline-header">
                        <span className="speak-badge">üîµ SPRECHWUNSCH</span>
                        <span className="speak-vehicle">{config.icon} {config.displayName} {vehicle.id}</span>
                      </div>
                      <div className="speak-message-inline">{vehicle.speakRequest || 'M√∂chte sprechen'}</div>
                      <button
                        className="answer-speak-btn-inline"
                        onClick={() => {
                          setVehicles(prev => prev.map(v =>
                            v.id === vehicle.id ? { ...v, status: 'S4', speakRequest: null } : v
                          ));
                          addLog(`S-${vehicle.id.toString().padStart(2, '0')} Sprechwunsch beantwortet`, 'assignment');
                        }}
                      >
                        ‚úì Best√§tigen
                      </button>
                    </div>
                  );
                })}

                {/* Funkspr√ºche darunter */}
                <RadioLog
                  messages={radioMessages}
                  onRespond={(messageId) => {
                    const message = radioMessages.find(m => m.id === messageId);
                    if (message && message.vehicleId) {
                      const hours = Math.floor(gameTime / 60);
                      const minutes = Math.floor(gameTime % 60);
                      const timestamp = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;

                      const responseId = radioMessageIdRef.current++;
                      const responseMessage: RadioMessage = {
                        id: responseId,
                        timestamp,
                        message: 'Verstanden',
                        type: 'outgoing',
                        requiresResponse: false,
                      };
                      setRadioMessages(prev => [...prev, responseMessage]);
                    }
                  }}
                />
              </div>
            </div>

            {/* Anrufe Section */}
            <div className="calls-section">
              <div className="panel-header-small">
                <h4>Anrufe</h4>
                <button className="new-call-btn-small" onClick={() => generateCall()}>+</button>
              </div>
              <div className="panel-content-small">
                {calls.length === 0 && (
                  <div className="empty-state-small">Keine eingehenden Anrufe</div>
                )}
                {calls.map(call => {
                  const timeAgo = Math.floor((Date.now() - call.timestamp) / 1000);

                  // Wartezeit-basierte Klasse
                  let waitTimeClass = 'wait-time-normal';
                  if (timeAgo > 120) {
                    waitTimeClass = 'wait-time-critical'; // 2+ Minuten - ROT + Pulsieren
                  } else if (timeAgo > 60) {
                    waitTimeClass = 'wait-time-urgent'; // 1-2 Minuten - ORANGE
                  } else if (timeAgo > 30) {
                    waitTimeClass = 'wait-time-warning'; // 30-60s - GELB
                  }

                  // Neu eingetroffene Anrufe blinken (erste 5 Sekunden)
                  const isNew = timeAgo < 5;

                  return (
                    <div
                      key={call.id}
                      className={`call-item-lstsim ${waitTimeClass} ${isNew ? 'call-new' : ''}`}
                    >
                      <div className="call-header-lstsim">
                        <span className="call-time-lstsim">{timeAgo}s</span>
                        <span className={`call-priority-badge priority-${call.priority}`}>
                          {call.priority === 'high' ? 'DRINGEND' : call.priority === 'medium' ? 'NORMAL' : 'NIEDRIG'}
                        </span>
                      </div>
                      <div className="call-type-lstsim">{call.type}</div>
                      <div className="call-location-lstsim">{call.locationName}</div>
                      <button
                        className="accept-call-btn-lstsim"
                        onClick={() => openCallModal(call.id)}
                      >
                        Anruf annehmen
                      </button>
                    </div>
                  );
                })}
              </div>
            </div>
          </div>
        </div>
      </div>

      {/* BOTTOM BAR: Minimalistisches Design */}
      <div className="bottom-bar">
        <div className="bottom-bar-left">
          <span className="time-text">{formattedTime}</span>
          <WeatherDisplay weather={weather} gameTime={gameTime} />
          <span className="score-text">{score}</span>
        </div>
        <div className="bottom-bar-center">
          <span className="station-name">{selectedStationData?.name}</span>
        </div>
        <div className="bottom-bar-right">
          <div className="speed-controls">
            <button
              className={`speed-btn ${gameSpeed === 1 && !isPaused ? 'active' : ''}`}
              onClick={() => { setGameSpeed(1); setIsPaused(false); }}
            >
              1√ó
            </button>
            <button
              className={`speed-btn ${gameSpeed === 2 && !isPaused ? 'active' : ''}`}
              onClick={() => { setGameSpeed(2); setIsPaused(false); }}
            >
              2√ó
            </button>
            <button
              className={`speed-btn ${gameSpeed === 3 && !isPaused ? 'active' : ''}`}
              onClick={() => { setGameSpeed(3); setIsPaused(false); }}
            >
              3√ó
            </button>
            <button
              className={`speed-btn ${gameSpeed === 4 && !isPaused ? 'active' : ''}`}
              onClick={() => { setGameSpeed(4); setIsPaused(false); }}
            >
              4√ó
            </button>
          </div>
          <button
            className={`pause-btn ${isPaused ? 'active' : ''}`}
            onClick={() => setIsPaused(!isPaused)}
          >
            {isPaused ? '‚ñ∂' : '‚è∏'}
          </button>
          <button className="footer-btn" onClick={() => setShowStatsModal(true)}>
            Statistik
          </button>
          <button className="footer-btn" onClick={() => setShowProtocolPanel(true)} title="Einsatzprotokoll √∂ffnen (Tastenk√ºrzel: L)">
            Protokoll
          </button>
        </div>
      </div>

      {/* Toast-Benachrichtigungen deaktiviert - Anrufe blinken stattdessen im Anruf-Bereich */}

      {showAchievementToast && (
        <div style={{
          position: 'fixed',
          top: '70px',
          left: '50%',
          transform: 'translateX(-50%)',
          background: '#30d158',
          color: 'white',
          padding: '16px 24px',
          borderRadius: '12px',
          boxShadow: '0 8px 32px rgba(0,0,0,0.2)',
          zIndex: 2000,
          fontSize: '15px',
          fontWeight: '600',
          animation: 'slideIn 0.3s ease-out',
        }}>
          {showAchievementToast.icon} {showAchievementToast.title} freigeschaltet!
        </div>
      )}

      <StatisticsModal
        isOpen={showStatsModal}
        onClose={() => setShowStatsModal(false)}
        stats={statistics}
      />

      <CallModal
        call={selectedCall}
        isOpen={isCallModalOpen}
        onClose={() => {
          setIsCallModalOpen(false);
          setSelectedCall(null);
        }}
        onAccept={acceptCall}
        onReject={rejectCall}
        availableVehicles={vehicles.filter(v => v.status === 'S1' || (v.status === 'S8' && v.canBeRedirected))}
      />

      <BackupModal
        incident={selectedIncidentForBackup}
        isOpen={isBackupModalOpen}
        onClose={() => {
          setIsBackupModalOpen(false);
          setSelectedIncidentForBackup(null);
        }}
        onConfirm={confirmBackup}
        availableVehicles={vehicles.filter(v =>
          (v.status === 'S1' || (v.status === 'S8' && v.canBeRedirected)) &&
          !selectedIncidentForBackup?.assignedVehicleIds.includes(v.id)
        )}
      />

      <ProtocolPanel
        isOpen={showProtocolPanel}
        onClose={() => setShowProtocolPanel(false)}
        entries={protocolEntries}
      />
    </div>
  );
}

export default App;
